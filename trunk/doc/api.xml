<haxe>
	<class path="haxe.io.BytesBuffer" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/BytesBuffer.hx">
		<b><c path="flash.utils.ByteArray"/></b>
		<addByte public="1" get="inline" set="null" line="55"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<add public="1" get="inline" set="null" line="69"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addBytes public="1" get="inline" set="null" line="84"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="106">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>
		Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.
	</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="41"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.text.TextLineMetrics" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/text/TextLineMetrics.hx" extern="1">
		<ascent public="1"><c path="Float"/></ascent>
		<descent public="1"><c path="Float"/></descent>
		<height public="1"><c path="Float"/></height>
		<leading public="1"><c path="Float"/></leading>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFieldType" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
	</enum>
	<class path="flash.display.IBitmapDrawable" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.BitmapData" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<height public="1" set="null"><c path="Int"/></height>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<transparent public="1" set="null"><e path="Bool"/></transparent>
		<width public="1" set="null"><c path="Int"/></width>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<e path="Void"/>
</f></applyFilter>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></colorTransform>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyPixels>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></floodFill>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<getPixel public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel>
		<getPixel32 public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel32>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<d/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<e path="Bool"/>
</f></hitTest>
		<lock public="1" set="method"><f a=""><e path="Void"/></f></lock>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></merge>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></paletteMap>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<c path="Int"/>
</f></pixelDissolve>
		<scroll public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<setPixel public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<t path="UInt"/>
</f></threshold>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="format.swf.TagId" params="" file="src/format/swf/Constants.hx" module="format.swf.Constants">
		<End public="1" get="inline" set="null" line="37" static="1"><c path="Int"/></End>
		<ShowFrame public="1" get="inline" set="null" line="38" static="1"><c path="Int"/></ShowFrame>
		<DefineShape public="1" get="inline" set="null" line="39" static="1"><c path="Int"/></DefineShape>
		<PlaceObject public="1" get="inline" set="null" line="40" static="1"><c path="Int"/></PlaceObject>
		<RemoveObject public="1" get="inline" set="null" line="41" static="1"><c path="Int"/></RemoveObject>
		<DefineBits public="1" get="inline" set="null" line="42" static="1"><c path="Int"/></DefineBits>
		<DefineButton public="1" get="inline" set="null" line="43" static="1"><c path="Int"/></DefineButton>
		<JPEGTables public="1" get="inline" set="null" line="44" static="1"><c path="Int"/></JPEGTables>
		<SetBackgroundColor public="1" get="inline" set="null" line="45" static="1"><c path="Int"/></SetBackgroundColor>
		<DefineFont public="1" get="inline" set="null" line="46" static="1"><c path="Int"/></DefineFont>
		<DefineText public="1" get="inline" set="null" line="47" static="1"><c path="Int"/></DefineText>
		<DoAction public="1" get="inline" set="null" line="48" static="1"><c path="Int"/></DoAction>
		<DefineFontInfo public="1" get="inline" set="null" line="49" static="1"><c path="Int"/></DefineFontInfo>
		<DefineSound public="1" get="inline" set="null" line="50" static="1"><c path="Int"/></DefineSound>
		<StartSound public="1" get="inline" set="null" line="51" static="1"><c path="Int"/></StartSound>
		<DefineButtonSound public="1" get="inline" set="null" line="52" static="1"><c path="Int"/></DefineButtonSound>
		<SoundStreamHead public="1" get="inline" set="null" line="53" static="1"><c path="Int"/></SoundStreamHead>
		<SoundStreamBlock public="1" get="inline" set="null" line="54" static="1"><c path="Int"/></SoundStreamBlock>
		<DefineBitsLossless public="1" get="inline" set="null" line="55" static="1"><c path="Int"/></DefineBitsLossless>
		<DefineBitsJPEG2 public="1" get="inline" set="null" line="56" static="1"><c path="Int"/></DefineBitsJPEG2>
		<DefineShape2 public="1" get="inline" set="null" line="57" static="1"><c path="Int"/></DefineShape2>
		<DefineButtonCxform public="1" get="inline" set="null" line="58" static="1"><c path="Int"/></DefineButtonCxform>
		<Protect public="1" get="inline" set="null" line="59" static="1"><c path="Int"/></Protect>
		<PlaceObject2 public="1" get="inline" set="null" line="60" static="1"><c path="Int"/></PlaceObject2>
		<RemoveObject2 public="1" get="inline" set="null" line="61" static="1"><c path="Int"/></RemoveObject2>
		<DefineShape3 public="1" get="inline" set="null" line="62" static="1"><c path="Int"/></DefineShape3>
		<DefineText2 public="1" get="inline" set="null" line="63" static="1"><c path="Int"/></DefineText2>
		<DefineButton2 public="1" get="inline" set="null" line="64" static="1"><c path="Int"/></DefineButton2>
		<DefineBitsJPEG3 public="1" get="inline" set="null" line="65" static="1"><c path="Int"/></DefineBitsJPEG3>
		<DefineBitsLossless2 public="1" get="inline" set="null" line="66" static="1"><c path="Int"/></DefineBitsLossless2>
		<DefineEditText public="1" get="inline" set="null" line="67" static="1"><c path="Int"/></DefineEditText>
		<DefineSprite public="1" get="inline" set="null" line="68" static="1"><c path="Int"/></DefineSprite>
		<FrameLabel public="1" get="inline" set="null" line="69" static="1"><c path="Int"/></FrameLabel>
		<SoundStreamHead2 public="1" get="inline" set="null" line="70" static="1"><c path="Int"/></SoundStreamHead2>
		<DefineMorphShape public="1" get="inline" set="null" line="71" static="1"><c path="Int"/></DefineMorphShape>
		<DefineFont2 public="1" get="inline" set="null" line="72" static="1"><c path="Int"/></DefineFont2>
		<ExportAssets public="1" get="inline" set="null" line="73" static="1"><c path="Int"/></ExportAssets>
		<ImportAssets public="1" get="inline" set="null" line="74" static="1"><c path="Int"/></ImportAssets>
		<EnableDebugger public="1" get="inline" set="null" line="75" static="1"><c path="Int"/></EnableDebugger>
		<DoInitAction public="1" get="inline" set="null" line="76" static="1"><c path="Int"/></DoInitAction>
		<DefineVideoStream public="1" get="inline" set="null" line="77" static="1"><c path="Int"/></DefineVideoStream>
		<VideoFrame public="1" get="inline" set="null" line="78" static="1"><c path="Int"/></VideoFrame>
		<DefineFontInfo2 public="1" get="inline" set="null" line="79" static="1"><c path="Int"/></DefineFontInfo2>
		<EnableDebugger2 public="1" get="inline" set="null" line="80" static="1"><c path="Int"/></EnableDebugger2>
		<ScriptLimits public="1" get="inline" set="null" line="81" static="1"><c path="Int"/></ScriptLimits>
		<SetTabIndex public="1" get="inline" set="null" line="82" static="1"><c path="Int"/></SetTabIndex>
		<FileAttributes public="1" get="inline" set="null" line="83" static="1"><c path="Int"/></FileAttributes>
		<PlaceObject3 public="1" get="inline" set="null" line="84" static="1"><c path="Int"/></PlaceObject3>
		<ImportAssets2 public="1" get="inline" set="null" line="85" static="1"><c path="Int"/></ImportAssets2>
		<RawABC public="1" get="inline" set="null" line="86" static="1"><c path="Int"/></RawABC>
		<DefineFontAlignZones public="1" get="inline" set="null" line="87" static="1"><c path="Int"/></DefineFontAlignZones>
		<CSMTextSettings public="1" get="inline" set="null" line="88" static="1"><c path="Int"/></CSMTextSettings>
		<DefineFont3 public="1" get="inline" set="null" line="89" static="1"><c path="Int"/></DefineFont3>
		<SymbolClass public="1" get="inline" set="null" line="90" static="1"><c path="Int"/></SymbolClass>
		<Metadata public="1" get="inline" set="null" line="91" static="1"><c path="Int"/></Metadata>
		<DefineScalingGrid public="1" get="inline" set="null" line="92" static="1"><c path="Int"/></DefineScalingGrid>
		<DoABC public="1" get="inline" set="null" line="93" static="1"><c path="Int"/></DoABC>
		<DefineShape4 public="1" get="inline" set="null" line="94" static="1"><c path="Int"/></DefineShape4>
		<DefineMorphShape2 public="1" get="inline" set="null" line="95" static="1"><c path="Int"/></DefineMorphShape2>
		<DefineSceneAndFrameLabelData public="1" get="inline" set="null" line="96" static="1"><c path="Int"/></DefineSceneAndFrameLabelData>
		<DefineBinaryData public="1" get="inline" set="null" line="97" static="1"><c path="Int"/></DefineBinaryData>
		<DefineFontName public="1" get="inline" set="null" line="98" static="1"><c path="Int"/></DefineFontName>
		<StartSound2 public="1" get="inline" set="null" line="99" static="1"><c path="Int"/></StartSound2>
		<DefineBitsJPEG4 public="1" get="inline" set="null" line="100" static="1"><c path="Int"/></DefineBitsJPEG4>
		<DefineFont4 public="1" get="inline" set="null" line="101" static="1"><c path="Int"/></DefineFont4>
		<haxe_doc>
 * Tag id constants
 * not for public usage
 </haxe_doc>
	</class>
	<class path="format.swf.FillStyleTypeId" params="" file="src/format/swf/Constants.hx" module="format.swf.Constants">
		<Solid public="1" get="inline" set="null" line="105" static="1"><c path="Int"/></Solid>
		<LinearGradient public="1" get="inline" set="null" line="106" static="1"><c path="Int"/></LinearGradient>
		<RadialGradient public="1" get="inline" set="null" line="107" static="1"><c path="Int"/></RadialGradient>
		<FocalRadialGradient public="1" get="inline" set="null" line="108" static="1"><c path="Int"/></FocalRadialGradient>
		<RepeatingBitmap public="1" get="inline" set="null" line="109" static="1"><c path="Int"/></RepeatingBitmap>
		<ClippedBitmap public="1" get="inline" set="null" line="110" static="1"><c path="Int"/></ClippedBitmap>
		<NonSmoothedRepeatingBitmap public="1" get="inline" set="null" line="111" static="1"><c path="Int"/></NonSmoothedRepeatingBitmap>
		<NonSmoothedClippedBitmap public="1" get="inline" set="null" line="112" static="1"><c path="Int"/></NonSmoothedClippedBitmap>
	</class>
	<class path="format.abc.Reader" params="" file="src/format/abc/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<opr><c path="format.abc.OpReader"/></opr>
		<functions public="1"><c path="Array"><t path="format.abc.Function"/></c></functions>
		<readInt get="inline" set="null" line="45"><f a=""><c path="Int"/></f></readInt>
		<readIndex params="T" get="inline" set="null" line="49"><f a=""><e path="format.abc.Index"><c path="readIndex.T"/></e></f></readIndex>
		<readIndexOpt params="T" set="method" line="53"><f a=""><t path="Null"><e path="format.abc.Index"><c path="readIndexOpt.T"/></e></t></f></readIndexOpt>
		<readList params="T" set="method" line="58"><f a="f">
	<f a=""><c path="readList.T"/></f>
	<c path="Array"><c path="readList.T"/></c>
</f></readList>
		<readList2 params="T" set="method" line="68"><f a="f">
	<f a=""><c path="readList2.T"/></f>
	<c path="Array"><c path="readList2.T"/></c>
</f></readList2>
		<readString set="method" line="76"><f a=""><c path="String"/></f></readString>
		<readNamespace set="method" line="80"><f a=""><e path="format.abc.Namespace"/></f></readNamespace>
		<readNsSet set="method" line="95"><f a=""><t path="format.abc.NamespaceSet"/></f></readNsSet>
		<readName set="method" line="102"><f a="?k">
	<c path="Int"/>
	<e path="format.abc.Name"/>
</f></readName>
		<readValue set="method" line="138"><f a="extra">
	<e path="Bool"/>
	<e path="format.abc.Value"/>
</f></readValue>
		<readMethodType set="method" line="158"><f a=""><t path="format.abc.MethodType"/></f></readMethodType>
		<readMetadata set="method" line="201"><f a=""><a>
	<name><e path="format.abc.Index"><c path="String"/></e></name>
	<data><c path="Array"><a>
	<v><e path="format.abc.Index"><c path="String"/></e></v>
	<n><t path="Null"><e path="format.abc.Index"><c path="String"/></e></t></n>
</a></c></data>
</a></f></readMetadata>
		<readField set="method" line="213"><f a=""><t path="format.abc.Field"/></f></readField>
		<readClass set="method" line="255"><f a=""><t path="format.abc.ClassDef"/></f></readClass>
		<readInit set="method" line="279"><f a=""><t path="format.abc.Init"/></f></readInit>
		<readTryCatch set="method" line="288"><f a=""><t path="format.abc.TryCatch"/></f></readTryCatch>
		<readFunction set="method" line="298"><f a=""><t path="format.abc.Function"/></f></readFunction>
		<read public="1" set="method" line="322"><f a=""><c path="format.abc.ABCData"/></f></read>
		<new public="1" set="method" line="38"><f a="i">
	<c path="haxe.io.Input"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/events/IEventDispatcher.hx" extern="1" interface="1">
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1">
			<f a="object">
				<d/>
				<c path="flash.display.LoaderInfo"/>
			</f>
			<haxe_doc> new in FP 9.0.115 </haxe_doc>
		</getLoaderInfoByDefinition>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<bytes public="1" set="null">
			<c path="flash.utils.ByteArray"/>
			<haxe_doc> new in FP 9.0.115 </haxe_doc>
		</bytes>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<childAllowsParent public="1" set="null"><e path="Bool"/></childAllowsParent>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<frameRate public="1" set="null"><c path="Float"/></frameRate>
		<height public="1" set="null"><c path="Int"/></height>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><e path="Bool"/></parentAllowsChild>
		<sameDomain public="1" set="null"><e path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<swfVersion public="1" set="null"><e path="flash.display.SWFVersion"/></swfVersion>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><c path="Int"/></width>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
	</enum>
	<class path="format.tools.BitsInput" params="" file="src/format/tools/BitsInput.hx">
		<i><c path="haxe.io.Input"/></i>
		<nbits><c path="Int"/></nbits>
		<bits><c path="Int"/></bits>
		<readBits public="1" set="method" line="41"><f a="n">
	<c path="Int"/>
	<c path="Int"/>
</f></readBits>
		<read public="1" set="method" line="63"><f a=""><e path="Bool"/></f></read>
		<reset public="1" get="inline" set="null" line="72"><f a=""><e path="Void"/></f></reset>
		<new public="1" set="method" line="35"><f a="i">
	<c path="haxe.io.Input"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.StageDisplayState" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN/>
	</enum>
	<class path="flash.Lib" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="Int"/></f></getTimer>
		<eval public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" set="method" line="55" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<fscommand public="1" set="method" line="63" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></fscommand>
		<trace public="1" set="method" line="67" static="1"><f a="arg">
	<d/>
	<e path="Void"/>
</f></trace>
		<attach public="1" set="method" line="71" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" get="inline" set="null" line="76" static="1"><f a="v:c">
	<d/>
	<c path="Class"><c path="as.T"/></c>
	<t path="Null"><c path="as.T"/></t>
</f></as>
	</class>
	<enum path="format.mp3.FrameType" params="" file="src/format/mp3/Reader.hx" module="format.mp3.Reader">
		<FT_NONE/>
		<FT_MP3/>
		<haxe_doc>
 * Used by seekFrame to retrun the type
 * of frame (possibly) found.
 </haxe_doc>
	</enum>
	<class path="format.mp3.Reader" params="" file="src/format/mp3/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<bits><c path="format.tools.BitsInput"/></bits>
		<version><c path="Int"/></version>
		<samples><c path="Int"/></samples>
		<sampleSize><c path="Int"/></sampleSize>
		<any_read><e path="Bool"/></any_read>
		<id3v2_data><c path="haxe.io.Bytes"/></id3v2_data>
		<id3v2_version><c path="Int"/></id3v2_version>
		<id3v2_flags><c path="Int"/></id3v2_flags>
		<skipID3v2 public="1" set="method" line="78">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
    * Called after found 'ID3' signature
    * at the beginning of the file.
    *
    * Records the raw tag data.
    </haxe_doc>
		</skipID3v2>
		<seekFrame public="1" set="method" line="101">
			<f a=""><e path="format.mp3.FrameType"/></f>
			<haxe_doc>
    * Winds the input stream until the 11-bit
    * syncword is found.
    *
    * @returns Bool false if not found (this should happen at eof).
    </haxe_doc>
		</seekFrame>
		<readFrames public="1" set="method" line="150">
			<f a=""><c path="Array"><t path="format.mp3.MP3Frame"/></c></f>
			<haxe_doc>
    * Returns all valid frames. Invalid frames
    * are discarded.
    </haxe_doc>
		</readFrames>
		<readFrameHeader public="1" set="method" line="170">
			<f a=""><t path="format.mp3.MP3Header"/></f>
			<haxe_doc>
    * Returns null if header proves to be invalid.
    </haxe_doc>
		</readFrameHeader>
		<readFrame public="1" set="method" line="250">
			<f a=""><t path="format.mp3.MP3Frame"/></f>
			<haxe_doc>
    * Reads a frame from the input.
    *
    * The input position should already be just past the
    * 11 bit syncword.
    *
    * Returns null if the header is invalid or the frame was incomplete.
    </haxe_doc>
		</readFrame>
		<read public="1" set="method" line="280">
			<f a=""><t path="format.mp3.MP3"/></f>
			<haxe_doc>
    * Reads the MP3 data. 
    *
    * Currently returns all valid frames.
    </haxe_doc>
		</read>
		<new public="1" set="method" line="62"><f a="i">
	<c path="haxe.io.Input"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="String" params="" file="C:\Program Files\Motion-Twin\haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<cca set="method"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></cca>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<typedef path="format.swf.Fixed" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><c path="haxe.Int32"/></typedef>
	<typedef path="format.swf.Fixed8" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><c path="Int"/></typedef>
	<typedef path="format.swf.SWF" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<tags><c path="Array"><e path="format.swf.SWFTag"/></c></tags>
	<header><t path="format.swf.SWFHeader"/></header>
</a></typedef>
	<enum path="format.swf.SWFTag" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<TUnknown a="id:data">
			<t path="Null"><c path="Int"/></t>
			<c path="haxe.io.Bytes"/>
		</TUnknown>
		<TSymbolClass a="symbols"><c path="Array"><t path="format.swf.SymData"/></c></TSymbolClass>
		<TStartSound a="id:soundInfo">
			<c path="Int"/>
			<t path="format.swf.SoundInfo"/>
		</TStartSound>
		<TSound a="data"><t path="format.swf.Sound"/></TSound>
		<TShowFrame/>
		<TShape a="id:data">
			<c path="Int"/>
			<e path="format.swf.ShapeData"/>
		</TShape>
		<TScriptLimits a="maxRecursion:timeoutSeconds">
			<c path="Int"/>
			<c path="Int"/>
		</TScriptLimits>
		<TSandBox a="v"><t path="format.swf.FileAttributes"/></TSandBox>
		<TRemoveObject2 a="depth"><c path="Int"/></TRemoveObject2>
		<TPlaceObject3 a="po"><c path="format.swf.PlaceObject"/></TPlaceObject3>
		<TPlaceObject2 a="po"><c path="format.swf.PlaceObject"/></TPlaceObject2>
		<TMorphShape a="id:data">
			<c path="Int"/>
			<e path="format.swf.MorphShapeData"/>
		</TMorphShape>
		<TMetadata a="data"><c path="String"/></TMetadata>
		<TJPEGTables a="data"><c path="haxe.io.Bytes"/></TJPEGTables>
		<TFrameLabel a="label:anchor">
			<c path="String"/>
			<e path="Bool"/>
		</TFrameLabel>
		<TFontInfo a="id:data">
			<c path="Int"/>
			<e path="format.swf.FontInfoData"/>
		</TFontInfo>
		<TFont a="id:data">
			<c path="Int"/>
			<e path="format.swf.FontData"/>
		</TFont>
		<TExportAssets a="symbols"><c path="Array"><t path="format.swf.SymData"/></c></TExportAssets>
		<TEnd/>
		<TDoInitActions a="id:data">
			<c path="Int"/>
			<c path="haxe.io.Bytes"/>
		</TDoInitActions>
		<TDoAction a="data"><c path="haxe.io.Bytes"/></TDoAction>
		<TDefineScalingGrid a="id:splitter">
			<c path="Int"/>
			<t path="format.swf.Rect"/>
		</TDefineScalingGrid>
		<TDefineEditText a="id:data">
			<c path="Int"/>
			<t path="format.swf.TextFieldData"/>
		</TDefineEditText>
		<TDefineButton2 a="id:records">
			<c path="Int"/>
			<c path="Array"><t path="format.swf.ButtonRecord"/></c>
		</TDefineButton2>
		<TClip a="id:frames:tags">
			<c path="Int"/>
			<c path="Int"/>
			<c path="Array"><e path="format.swf.SWFTag"/></c>
		</TClip>
		<TBitsLossless2 a="data"><t path="format.swf.Lossless"/></TBitsLossless2>
		<TBitsLossless a="data"><t path="format.swf.Lossless"/></TBitsLossless>
		<TBitsJPEG a="id:data">
			<c path="Int"/>
			<e path="format.swf.JPEGData"/>
		</TBitsJPEG>
		<TBinaryData a="id:data">
			<c path="Int"/>
			<c path="haxe.io.Bytes"/>
		</TBinaryData>
		<TBackgroundColor a="color"><c path="Int"/></TBackgroundColor>
		<TActionScript3 a="data:?context">
			<c path="haxe.io.Bytes"/>
			<t path="format.swf.AS3Context"/>
		</TActionScript3>
	</enum>
	<typedef path="format.swf.TextFieldData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<wordWrap><e path="Bool"/></wordWrap>
	<wasStatic><e path="Bool"/></wasStatic>
	<variableName><c path="String"/></variableName>
	<useOutlines><e path="Bool"/></useOutlines>
	<textColor><t path="format.swf.RGBA"/></textColor>
	<selectable><e path="Bool"/></selectable>
	<rightMargin><c path="Int"/></rightMargin>
	<password><e path="Bool"/></password>
	<multiline><e path="Bool"/></multiline>
	<maxLength><c path="Int"/></maxLength>
	<leftMargin><c path="Int"/></leftMargin>
	<leading><c path="Int"/></leading>
	<input><e path="Bool"/></input>
	<initialText><c path="String"/></initialText>
	<indent><c path="Int"/></indent>
	<html><e path="Bool"/></html>
	<hasTextColor><e path="Bool"/></hasTextColor>
	<hasText><e path="Bool"/></hasText>
	<hasMaxLength><e path="Bool"/></hasMaxLength>
	<hasLayout><e path="Bool"/></hasLayout>
	<hasFontClass><e path="Bool"/></hasFontClass>
	<hasFont><e path="Bool"/></hasFont>
	<fontID><c path="Int"/></fontID>
	<fontHeight><c path="Int"/></fontHeight>
	<fontClass><c path="String"/></fontClass>
	<bounds><t path="format.swf.Rect"/></bounds>
	<border><e path="Bool"/></border>
	<autoSize><e path="Bool"/></autoSize>
	<align><c path="Int"/></align>
</a></typedef>
	<typedef path="format.swf.ButtonRecord" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<up><e path="Bool"/></up>
	<over><e path="Bool"/></over>
	<matrix><t path="Null"><t path="format.swf.Matrix"/></t></matrix>
	<id><c path="Int"/></id>
	<hit><e path="Bool"/></hit>
	<down><e path="Bool"/></down>
	<depth><c path="Int"/></depth>
</a></typedef>
	<typedef path="format.swf.SoundInfo" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<syncStop><e path="Bool"/></syncStop>
	<loopCount><t path="Null"><c path="Int"/></t></loopCount>
	<hasLoops><e path="Bool"/></hasLoops>
</a></typedef>
	<typedef path="format.swf.SoundEnvelope" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<rightLevel><c path="Int"/></rightLevel>
	<pos44><c path="Int"/></pos44>
	<leftLevel><c path="Int"/></leftLevel>
</a></typedef>
	<typedef path="format.swf.FileAttributes" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<useNetWork><e path="Bool"/></useNetWork>
	<useGPU><e path="Bool"/></useGPU>
	<useDirectBlit><e path="Bool"/></useDirectBlit>
	<hasMetaData><e path="Bool"/></hasMetaData>
	<actionscript3><e path="Bool"/></actionscript3>
</a></typedef>
	<typedef path="format.swf.SWFHeader" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<width><c path="Int"/></width>
	<version><c path="Int"/></version>
	<nframes><c path="Int"/></nframes>
	<height><c path="Int"/></height>
	<fps><t path="format.swf.Fixed8"/></fps>
	<compressed><e path="Bool"/></compressed>
</a></typedef>
	<typedef path="format.swf.AS3Context" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<label><c path="String"/></label>
	<id><c path="Int"/></id>
</a></typedef>
	<typedef path="format.swf.SymData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<className><c path="String"/></className>
	<cid><c path="Int"/></cid>
</a></typedef>
	<class path="format.swf.PlaceObject" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<depth public="1"><c path="Int"/></depth>
		<move public="1"><e path="Bool"/></move>
		<cid public="1"><t path="Null"><c path="Int"/></t></cid>
		<matrix public="1"><t path="Null"><t path="format.swf.Matrix"/></t></matrix>
		<color public="1"><t path="Null"><t path="format.swf.CXA"/></t></color>
		<ratio public="1"><t path="Null"><c path="Int"/></t></ratio>
		<instanceName public="1"><t path="Null"><c path="String"/></t></instanceName>
		<clipDepth public="1"><t path="Null"><c path="Int"/></t></clipDepth>
		<events public="1"><t path="Null"><c path="Array"><t path="format.swf.ClipEvent"/></c></t></events>
		<filters public="1"><t path="Null"><c path="Array"><e path="format.swf.Filter"/></c></t></filters>
		<blendMode public="1"><t path="Null"><e path="format.swf.BlendMode"/></t></blendMode>
		<bitmapCache public="1"><e path="Bool"/></bitmapCache>
		<new public="1" set="method" line="168"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="format.swf.Rect" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<top><c path="Int"/></top>
	<right><c path="Int"/></right>
	<left><c path="Int"/></left>
	<bottom><c path="Int"/></bottom>
</a></typedef>
	<enum path="format.swf.ShapeData" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<SHDShape4 a="data"><t path="format.swf.Shape4Data"/></SHDShape4>
		<SHDShape3 a="bounds:shapes">
			<t path="format.swf.Rect"/>
			<t path="format.swf.ShapeWithStyleData"/>
		</SHDShape3>
		<SHDShape2 a="bounds:shapes">
			<t path="format.swf.Rect"/>
			<t path="format.swf.ShapeWithStyleData"/>
		</SHDShape2>
		<SHDShape1 a="bounds:shapes">
			<t path="format.swf.Rect"/>
			<t path="format.swf.ShapeWithStyleData"/>
		</SHDShape1>
	</enum>
	<enum path="format.swf.MorphShapeData" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<MSDShape2 a="data"><t path="format.swf.MorphShapeData2"/></MSDShape2>
		<MSDShape1 a="data"><t path="format.swf.MorphShapeData1"/></MSDShape1>
	</enum>
	<typedef path="format.swf.MorphShapeData1" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<startEdges><t path="format.swf.ShapeWithoutStyleData"/></startEdges>
	<startBounds><t path="format.swf.Rect"/></startBounds>
	<lineStyles><c path="Array"><t path="format.swf.Morph1LineStyle"/></c></lineStyles>
	<fillStyles><c path="Array"><e path="format.swf.MorphFillStyle"/></c></fillStyles>
	<endEdges><t path="format.swf.ShapeWithoutStyleData"/></endEdges>
	<endBounds><t path="format.swf.Rect"/></endBounds>
</a></typedef>
	<typedef path="format.swf.MorphShapeData2" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<useScalingStrokes><e path="Bool"/></useScalingStrokes>
	<useNonScalingStrokes><e path="Bool"/></useNonScalingStrokes>
	<startEdges><t path="format.swf.ShapeWithoutStyleData"/></startEdges>
	<startEdgeBounds><t path="format.swf.Rect"/></startEdgeBounds>
	<startBounds><t path="format.swf.Rect"/></startBounds>
	<lineStyles><c path="Array"><e path="format.swf.Morph2LineStyle"/></c></lineStyles>
	<fillStyles><c path="Array"><e path="format.swf.MorphFillStyle"/></c></fillStyles>
	<endEdges><t path="format.swf.ShapeWithoutStyleData"/></endEdges>
	<endEdgeBounds><t path="format.swf.Rect"/></endEdgeBounds>
	<endBounds><t path="format.swf.Rect"/></endBounds>
</a></typedef>
	<enum path="format.swf.MorphFillStyle" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<MFSSolid a="startColor:endColor">
			<t path="format.swf.RGBA"/>
			<t path="format.swf.RGBA"/>
		</MFSSolid>
		<MFSRadialGradient a="startMatrix:endMatrix:gradients">
			<t path="format.swf.Matrix"/>
			<t path="format.swf.Matrix"/>
			<c path="Array"><t path="format.swf.MorphGradient"/></c>
		</MFSRadialGradient>
		<MFSLinearGradient a="startMatrix:endMatrix:gradients">
			<t path="format.swf.Matrix"/>
			<t path="format.swf.Matrix"/>
			<c path="Array"><t path="format.swf.MorphGradient"/></c>
		</MFSLinearGradient>
		<MFSBitmap a="cid:startMatrix:endMatrix:repeat:smooth">
			<c path="Int"/>
			<t path="format.swf.Matrix"/>
			<t path="format.swf.Matrix"/>
			<e path="Bool"/>
			<e path="Bool"/>
		</MFSBitmap>
	</enum>
	<typedef path="format.swf.Morph1LineStyle" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<startWidth><c path="Int"/></startWidth>
	<startColor><t path="format.swf.RGBA"/></startColor>
	<endWidth><c path="Int"/></endWidth>
	<endColor><t path="format.swf.RGBA"/></endColor>
</a></typedef>
	<enum path="format.swf.Morph2LineStyle" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<M2LSNoFill a="startColor:endColor:data">
			<t path="format.swf.RGBA"/>
			<t path="format.swf.RGBA"/>
			<t path="format.swf.Morph2LineStyleData"/>
		</M2LSNoFill>
		<M2LSFill a="fill:data">
			<e path="format.swf.MorphFillStyle"/>
			<t path="format.swf.Morph2LineStyleData"/>
		</M2LSFill>
	</enum>
	<typedef path="format.swf.Morph2LineStyleData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<startWidth><c path="Int"/></startWidth>
	<startCapStyle><e path="format.swf.LineCapStyle"/></startCapStyle>
	<pixelHinting><e path="Bool"/></pixelHinting>
	<noVScale><e path="Bool"/></noVScale>
	<noHScale><e path="Bool"/></noHScale>
	<noClose><e path="Bool"/></noClose>
	<joinStyle><e path="format.swf.LineJoinStyle"/></joinStyle>
	<endWidth><c path="Int"/></endWidth>
	<endCapStyle><e path="format.swf.LineCapStyle"/></endCapStyle>
</a></typedef>
	<typedef path="format.swf.MorphGradient" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<startRatio><c path="Int"/></startRatio>
	<startColor><t path="format.swf.RGBA"/></startColor>
	<endRatio><c path="Int"/></endRatio>
	<endColor><t path="format.swf.RGBA"/></endColor>
</a></typedef>
	<typedef path="format.swf.Shape4Data" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<useWinding><e path="Bool"/></useWinding>
	<useScalingStroke><e path="Bool"/></useScalingStroke>
	<useNonScalingStroke><e path="Bool"/></useNonScalingStroke>
	<shapes><t path="format.swf.ShapeWithStyleData"/></shapes>
	<shapeBounds><t path="format.swf.Rect"/></shapeBounds>
	<edgeBounds><t path="format.swf.Rect"/></edgeBounds>
</a></typedef>
	<typedef path="format.swf.ShapeWithoutStyleData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a><shapeRecords><c path="Array"><e path="format.swf.ShapeRecord"/></c></shapeRecords></a></typedef>
	<typedef path="format.swf.ShapeWithStyleData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<shapeRecords><c path="Array"><e path="format.swf.ShapeRecord"/></c></shapeRecords>
	<lineStyles><c path="Array"><t path="format.swf.LineStyle"/></c></lineStyles>
	<fillStyles><c path="Array"><e path="format.swf.FillStyle"/></c></fillStyles>
</a></typedef>
	<enum path="format.swf.ShapeRecord" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<SHREnd/>
		<SHREdge a="dx:dy">
			<c path="Int"/>
			<c path="Int"/>
		</SHREdge>
		<SHRCurvedEdge a="cdx:cdy:adx:ady">
			<c path="Int"/>
			<c path="Int"/>
			<c path="Int"/>
			<c path="Int"/>
		</SHRCurvedEdge>
		<SHRChange a="data"><t path="format.swf.ShapeChangeRec"/></SHRChange>
	</enum>
	<typedef path="format.swf.ShapeChangeRec" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<newStyles><t path="Null"><t path="format.swf.SCRNewStyles"/></t></newStyles>
	<moveTo><t path="Null"><t path="format.swf.SCRMoveTo"/></t></moveTo>
	<lineStyle><t path="Null"><t path="format.swf.SCRIndex"/></t></lineStyle>
	<fillStyle1><t path="Null"><t path="format.swf.SCRIndex"/></t></fillStyle1>
	<fillStyle0><t path="Null"><t path="format.swf.SCRIndex"/></t></fillStyle0>
</a></typedef>
	<typedef path="format.swf.SCRMoveTo" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<dy><c path="Int"/></dy>
	<dx><c path="Int"/></dx>
</a></typedef>
	<typedef path="format.swf.SCRIndex" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a><idx><c path="Int"/></idx></a></typedef>
	<typedef path="format.swf.SCRNewStyles" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<lineStyles><c path="Array"><t path="format.swf.LineStyle"/></c></lineStyles>
	<fillStyles><c path="Array"><e path="format.swf.FillStyle"/></c></fillStyles>
</a></typedef>
	<enum path="format.swf.FillStyle" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<FSSolidAlpha a="rgb"><t path="format.swf.RGBA"/></FSSolidAlpha>
		<FSSolid a="rgb"><t path="format.swf.RGB"/></FSSolid>
		<FSRadialGradient a="mat:grad">
			<t path="format.swf.Matrix"/>
			<t path="format.swf.Gradient"/>
		</FSRadialGradient>
		<FSLinearGradient a="mat:grad">
			<t path="format.swf.Matrix"/>
			<t path="format.swf.Gradient"/>
		</FSLinearGradient>
		<FSFocalGradient a="mat:grad">
			<t path="format.swf.Matrix"/>
			<t path="format.swf.FocalGradient"/>
		</FSFocalGradient>
		<FSBitmap a="cid:mat:repeat:smooth">
			<c path="Int"/>
			<t path="format.swf.Matrix"/>
			<e path="Bool"/>
			<e path="Bool"/>
		</FSBitmap>
	</enum>
	<typedef path="format.swf.LineStyle" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<width><c path="Int"/></width>
	<data><e path="format.swf.LineStyleData"/></data>
</a></typedef>
	<enum path="format.swf.LineStyleData" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<LSRGBA a="rgba"><t path="format.swf.RGBA"/></LSRGBA>
		<LSRGB a="rgb"><t path="format.swf.RGB"/></LSRGB>
		<LS2 a="data"><t path="format.swf.LS2Data"/></LS2>
	</enum>
	<typedef path="format.swf.LS2Data" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<startCap><e path="format.swf.LineCapStyle"/></startCap>
	<pixelHinting><e path="Bool"/></pixelHinting>
	<noVScale><e path="Bool"/></noVScale>
	<noHScale><e path="Bool"/></noHScale>
	<noClose><e path="Bool"/></noClose>
	<join><e path="format.swf.LineJoinStyle"/></join>
	<fill><t path="Null"><e path="format.swf.LS2Fill"/></t></fill>
	<endCap><e path="format.swf.LineCapStyle"/></endCap>
</a></typedef>
	<enum path="format.swf.LineCapStyle" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<LCSquare/>
		<LCRound/>
		<LCNone/>
	</enum>
	<enum path="format.swf.LineJoinStyle" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<LJRound/>
		<LJMiter a="limitFactor"><t path="format.swf.Fixed8"/></LJMiter>
		<LJBevel/>
	</enum>
	<enum path="format.swf.LS2Fill" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<LS2FStyle a="style"><e path="format.swf.FillStyle"/></LS2FStyle>
		<LS2FColor a="color"><t path="format.swf.RGBA"/></LS2FColor>
	</enum>
	<enum path="format.swf.GradRecord" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<GRRGBA a="pos:col">
			<c path="Int"/>
			<t path="format.swf.RGBA"/>
		</GRRGBA>
		<GRRGB a="pos:col">
			<c path="Int"/>
			<t path="format.swf.RGB"/>
		</GRRGB>
	</enum>
	<typedef path="format.swf.Gradient" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<spread><e path="format.swf.SpreadMode"/></spread>
	<interpolate><e path="format.swf.InterpolationMode"/></interpolate>
	<data><c path="Array"><e path="format.swf.GradRecord"/></c></data>
</a></typedef>
	<typedef path="format.swf.FocalGradient" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<focalPoint><t path="format.swf.Fixed8"/></focalPoint>
	<data><t path="format.swf.Gradient"/></data>
</a></typedef>
	<enum path="format.swf.SpreadMode" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<SMReserved/>
		<SMRepeat/>
		<SMReflect/>
		<SMPad/>
	</enum>
	<enum path="format.swf.InterpolationMode" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<IMReserved2/>
		<IMReserved1/>
		<IMNormalRGB/>
		<IMLinearRGB/>
	</enum>
	<typedef path="format.swf.MatrixPart" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<y><c path="Int"/></y>
	<x><c path="Int"/></x>
	<nbits><c path="Int"/></nbits>
</a></typedef>
	<typedef path="format.swf.MatrixPartScale" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></typedef>
	<typedef path="format.swf.MatrixPartRotateSkew" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<rs1><c path="Float"/></rs1>
	<rs0><c path="Float"/></rs0>
</a></typedef>
	<typedef path="format.swf.MatrixPartTranslate" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<y><c path="Int"/></y>
	<x><c path="Int"/></x>
</a></typedef>
	<typedef path="format.swf.Matrix" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<translate><t path="format.swf.MatrixPartTranslate"/></translate>
	<scale><t path="Null"><t path="format.swf.MatrixPartScale"/></t></scale>
	<rotate><t path="Null"><t path="format.swf.MatrixPartRotateSkew"/></t></rotate>
</a></typedef>
	<typedef path="format.swf.RGBA" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<r><c path="Int"/></r>
	<g><c path="Int"/></g>
	<b><c path="Int"/></b>
	<a><c path="Int"/></a>
</a></typedef>
	<typedef path="format.swf.RGB" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<r><c path="Int"/></r>
	<g><c path="Int"/></g>
	<b><c path="Int"/></b>
</a></typedef>
	<typedef path="format.swf.CXA" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<nbits><c path="Int"/></nbits>
	<mult><t path="Null"><t path="format.swf.RGBA"/></t></mult>
	<add><t path="Null"><t path="format.swf.RGBA"/></t></add>
</a></typedef>
	<typedef path="format.swf.ClipEvent" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<eventsFlags><c path="Int"/></eventsFlags>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<enum path="format.swf.BlendMode" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<BSubtract/>
		<BScreen/>
		<BOverlay/>
		<BNormal/>
		<BMultiply/>
		<BLighten/>
		<BLayer/>
		<BInvert/>
		<BHardLight/>
		<BErase/>
		<BDifference/>
		<BDarken/>
		<BAlpha/>
		<BAdd/>
	</enum>
	<enum path="format.swf.Filter" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<FGradientGlow a="data"><t path="format.swf.GradientFilterData"/></FGradientGlow>
		<FGradientBevel a="data"><t path="format.swf.GradientFilterData"/></FGradientBevel>
		<FGlow a="data"><t path="format.swf.FilterData"/></FGlow>
		<FDropShadow a="data"><t path="format.swf.FilterData"/></FDropShadow>
		<FColorMatrix a="data"><c path="Array"><c path="Float"/></c></FColorMatrix>
		<FBlur a="data"><t path="format.swf.BlurFilterData"/></FBlur>
		<FBevel a="data"><t path="format.swf.FilterData"/></FBevel>
	</enum>
	<typedef path="format.swf.FilterFlags" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<passes><c path="Int"/></passes>
	<ontop><e path="Bool"/></ontop>
	<knockout><e path="Bool"/></knockout>
	<inner><e path="Bool"/></inner>
</a></typedef>
	<typedef path="format.swf.FilterData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<strength><t path="format.swf.Fixed8"/></strength>
	<flags><t path="format.swf.FilterFlags"/></flags>
	<distance><t path="format.swf.Fixed"/></distance>
	<color2><t path="format.swf.RGBA"/></color2>
	<color><t path="format.swf.RGBA"/></color>
	<blurY><t path="format.swf.Fixed"/></blurY>
	<blurX><t path="format.swf.Fixed"/></blurX>
	<angle><t path="format.swf.Fixed"/></angle>
</a></typedef>
	<typedef path="format.swf.BlurFilterData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<passes><c path="Int"/></passes>
	<blurY><t path="format.swf.Fixed"/></blurY>
	<blurX><t path="format.swf.Fixed"/></blurX>
</a></typedef>
	<typedef path="format.swf.GradientFilterData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<data><t path="format.swf.FilterData"/></data>
	<colors><c path="Array"><a>
	<position><c path="Int"/></position>
	<color><t path="format.swf.RGBA"/></color>
</a></c></colors>
</a></typedef>
	<typedef path="format.swf.Lossless" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<width><c path="Int"/></width>
	<height><c path="Int"/></height>
	<data><c path="haxe.io.Bytes"/></data>
	<color><e path="format.swf.ColorModel"/></color>
	<cid><c path="Int"/></cid>
</a></typedef>
	<enum path="format.swf.JPEGData" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<JDJPEG3 a="data:mask">
			<c path="haxe.io.Bytes"/>
			<c path="haxe.io.Bytes"/>
		</JDJPEG3>
		<JDJPEG2 a="data"><c path="haxe.io.Bytes"/></JDJPEG2>
		<JDJPEG1 a="data"><c path="haxe.io.Bytes"/></JDJPEG1>
	</enum>
	<enum path="format.swf.ColorModel" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<CM8Bits a="ncolors"><c path="Int"/></CM8Bits>
		<CM32Bits/>
		<CM24Bits/>
		<CM15Bits/>
	</enum>
	<typedef path="format.swf.VideoInfo" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<width><c path="Int"/></width>
	<smoothing><e path="Bool"/></smoothing>
	<numFrames><c path="Int"/></numFrames>
	<height><c path="Int"/></height>
	<deblocking><e path="Bool"/></deblocking>
	<codecId><c path="Int"/></codecId>
</a></typedef>
	<enum path="format.swf.VideoData" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<VP6SWFvideoPacket/>
		<VP6SWFALPHAvideoPacket/>
		<SCREENvideoPacket/>
		<SCREENV2videoPacket/>
		<H263videoPacket/>
	</enum>
	<typedef path="format.swf.Sound" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<sid><c path="Int"/></sid>
	<samples><c path="haxe.Int32"/></samples>
	<rate><e path="format.swf.SoundRate"/></rate>
	<isStereo><e path="Bool"/></isStereo>
	<is16bit><e path="Bool"/></is16bit>
	<format><e path="format.swf.SoundFormat"/></format>
	<data><e path="format.swf.SoundData"/></data>
</a></typedef>
	<typedef path="format.swf.SoundStreamHead2" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<streamSoundType><e path="Bool"/></streamSoundType>
	<streamSoundSize><e path="Bool"/></streamSoundSize>
	<streamSoundSampleCount><c path="Int"/></streamSoundSampleCount>
	<streamSoundRate><c path="Int"/></streamSoundRate>
	<streamSoundCompression><c path="Int"/></streamSoundCompression>
	<playbackSoundType><e path="Bool"/></playbackSoundType>
	<playbackSoundSize><c path="Int"/></playbackSoundSize>
	<playbackSoundRate><c path="Int"/></playbackSoundRate>
	<latencySeek><t path="Null"><c path="Int"/></t></latencySeek>
</a></typedef>
	<typedef path="format.swf.MP3streamSoundData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<sampleCount><c path="Int"/></sampleCount>
	<mp3SoundData><c path="Array"><t path="format.swf._MP3Frame"/></c></mp3SoundData>
</a></typedef>
	<enum path="format.swf.SoundData" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<SDRaw a="data"><c path="haxe.io.Bytes"/></SDRaw>
		<SDOther a="data"><c path="haxe.io.Bytes"/></SDOther>
		<SDMp3 a="seek:data">
			<c path="Int"/>
			<c path="haxe.io.Bytes"/>
		</SDMp3>
	</enum>
	<enum path="format.swf.SoundFormat" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<SFSpeex/>
		<SFNellymoser8k/>
		<SFNellymoser16k/>
		<SFNellymoser/>
		<SFNativeEndianUncompressed/>
		<SFMP3/>
		<SFLittleEndianUncompressed/>
		<SFADPCM/>
	</enum>
	<enum path="format.swf.SoundRate" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<SR5k/>
		<SR44k/>
		<SR22k/>
		<SR11k/>
		<haxe_doc>
 * Sound sampling rate.
 *
 * - 5k is not allowed for MP3
 * - Nellymoser and Speex ignore this option
 </haxe_doc>
	</enum>
	<enum path="format.swf.FontData" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<FDFont3 a="data"><t path="format.swf.Font2Data"/></FDFont3>
		<FDFont2 a="hasWideChars:data">
			<e path="Bool"/>
			<t path="format.swf.Font2Data"/>
		</FDFont2>
		<FDFont1 a="data"><t path="format.swf.Font1Data"/></FDFont1>
	</enum>
	<enum path="format.swf.FontInfoData" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<FIDFont2 a="language:data">
			<e path="format.swf.LangCode"/>
			<t path="format.swf.FIData"/>
		</FIDFont2>
		<FIDFont1 a="shiftJIS:isANSI:hasWideCodes:data">
			<e path="Bool"/>
			<e path="Bool"/>
			<e path="Bool"/>
			<t path="format.swf.FIData"/>
		</FIDFont1>
	</enum>
	<typedef path="format.swf.FIData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<name><c path="String"/></name>
	<isSmall><e path="Bool"/></isSmall>
	<isItalic><e path="Bool"/></isItalic>
	<isBold><e path="Bool"/></isBold>
	<codeTable><c path="Array"><c path="Int"/></c></codeTable>
</a></typedef>
	<enum path="format.swf.LangCode" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<LCTraditionalChinese/>
		<LCSimplifiedChinese/>
		<LCNone/>
		<LCLatin/>
		<LCKorean/>
		<LCJapanese/>
	</enum>
	<typedef path="format.swf.Font1Data" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a><glyphs><c path="Array"><t path="format.swf.ShapeWithoutStyleData"/></c></glyphs></a></typedef>
	<typedef path="format.swf.Font2GlyphData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<shape><t path="format.swf.ShapeWithoutStyleData"/></shape>
	<charCode><c path="Int"/></charCode>
</a></typedef>
	<typedef path="format.swf.Font2Data" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<shiftJIS><e path="Bool"/></shiftJIS>
	<name><c path="String"/></name>
	<layout><t path="Null"><t path="format.swf.FontLayoutData"/></t></layout>
	<language><e path="format.swf.LangCode"/></language>
	<isSmall><e path="Bool"/></isSmall>
	<isItalic><e path="Bool"/></isItalic>
	<isBold><e path="Bool"/></isBold>
	<isANSI><e path="Bool"/></isANSI>
	<glyphs><c path="Array"><t path="format.swf.Font2GlyphData"/></c></glyphs>
</a></typedef>
	<typedef path="format.swf.FontKerningData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<charCode2><c path="Int"/></charCode2>
	<charCode1><c path="Int"/></charCode1>
	<adjust><c path="Int"/></adjust>
</a></typedef>
	<typedef path="format.swf.FontLayoutGlyphData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<bounds><t path="format.swf.Rect"/></bounds>
	<advance><c path="Int"/></advance>
</a></typedef>
	<typedef path="format.swf.FontLayoutData" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<leading><c path="Int"/></leading>
	<kerning><c path="Array"><t path="format.swf.FontKerningData"/></c></kerning>
	<glyphs><c path="Array"><t path="format.swf.FontLayoutGlyphData"/></c></glyphs>
	<descent><c path="Int"/></descent>
	<ascent><c path="Int"/></ascent>
</a></typedef>
	<typedef path="format.swf._MP3Frame" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<header><t path="format.swf._MP3Header"/></header>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<typedef path="format.swf._MP3Header" params="" file="src/format/swf/Data.hx" module="format.swf.Data"><a>
	<version><e path="format.swf.MPEGVersion"/></version>
	<samplingRate><e path="format.swf.SamplingRate"/></samplingRate>
	<privateBit><e path="Bool"/></privateBit>
	<layer><e path="format.swf.Layer"/></layer>
	<isPadded><e path="Bool"/></isPadded>
	<isOriginal><e path="Bool"/></isOriginal>
	<isMSStereo><e path="Bool"/></isMSStereo>
	<isIntensityStereo><e path="Bool"/></isIntensityStereo>
	<isCopyrighted><e path="Bool"/></isCopyrighted>
	<hasCrc><e path="Bool"/></hasCrc>
	<emphasis><e path="format.swf.Emphasis"/></emphasis>
	<crc16><c path="Int"/></crc16>
	<channelMode><e path="format.swf.ChannelMode"/></channelMode>
	<bitrate><e path="format.swf.Bitrate"/></bitrate>
</a></typedef>
	<enum path="format.swf.MPEGVersion" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<MPEG_V25/>
		<MPEG_V2/>
		<MPEG_V1/>
		<MPEG_Reserved/>
	</enum>
	<enum path="format.swf.Bitrate" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<BR_Free/>
		<BR_Bad/>
		<BR_96/>
		<BR_80/>
		<BR_8/>
		<BR_64/>
		<BR_56/>
		<BR_48/>
		<BR_448/>
		<BR_416/>
		<BR_40/>
		<BR_384/>
		<BR_352/>
		<BR_320/>
		<BR_32/>
		<BR_288/>
		<BR_256/>
		<BR_24/>
		<BR_224/>
		<BR_192/>
		<BR_176/>
		<BR_160/>
		<BR_16/>
		<BR_144/>
		<BR_128/>
		<BR_112/>
	</enum>
	<enum path="format.swf.SamplingRate" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<SR_Bad/>
		<SR_8000/>
		<SR_48000/>
		<SR_44100/>
		<SR_32000/>
		<SR_24000/>
		<SR_22050/>
		<SR_12000/>
		<SR_11025/>
	</enum>
	<enum path="format.swf.Layer" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<LayerReserved/>
		<Layer3/>
		<Layer2/>
		<Layer1/>
	</enum>
	<enum path="format.swf.ChannelMode" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<Stereo/>
		<Mono/>
		<JointStereo/>
		<DualChannel/>
	</enum>
	<enum path="format.swf.Emphasis" params="" file="src/format/swf/Data.hx" module="format.swf.Data">
		<NoEmphasis/>
		<Ms50_15/>
		<InvalidEmphasis/>
		<CCIT_J17/>
	</enum>
	<class path="flash.net.URLRequestHeader" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/net/URLRequestHeader.hx" extern="1">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.LoaderContext" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/system/LoaderContext.hx" extern="1">
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<e path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.GradientType" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
	</enum>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/accessibility/AccessibilityImplementation.hx" extern="1">
		<errno public="1"><t path="UInt"/></errno>
		<stub public="1"><e path="Bool"/></stub>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<e path="Void"/>
</f></accDoDefaultAction>
		<accLocation public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<d/>
</f></accLocation>
		<accSelect public="1" set="method"><f a="operation:childID">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></accSelect>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<get_accFocus public="1" set="method"><f a=""><t path="UInt"/></f></get_accFocus>
		<get_accName public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accRole public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accRole>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accState public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accState>
		<get_accValue public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></isLabeledBy>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="List" params="T" file="C:\Program Files\Motion-Twin\haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="56">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="76">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="100">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="108">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="118">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="132">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="149">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="190">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="215">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="235">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="254">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="270">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" set="method" line="49">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<enum path="Void" params="" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="UInt" params="" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Int"/>
		<haxe_doc>
	The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.
</haxe_doc>
	</typedef>
	<typedef path="Null" params="T" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next><f a=""><c path="Iterator.T"/></f></next>
			<hasNext><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="flash.display.DisplayObject" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
		<alpha public="1"><c path="Float"/></alpha>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<cacheAsBitmap public="1"><e path="Bool"/></cacheAsBitmap>
		<filters public="1"><c path="Array"><d/></c></filters>
		<height public="1"><c path="Float"/></height>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<mouseX public="1" set="null"><c path="Float"/></mouseX>
		<mouseY public="1" set="null"><c path="Float"/></mouseY>
		<name public="1"><c path="String"/></name>
		<opaqueBackground public="1"><t path="Null"><t path="UInt"/></t></opaqueBackground>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<rotation public="1"><c path="Float"/></rotation>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<scaleX public="1"><c path="Float"/></scaleX>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<visible public="1"><e path="Bool"/></visible>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></hitTestPoint>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<focusRect public="1"><d/></focusRect>
		<mouseEnabled public="1"><e path="Bool"/></mouseEnabled>
		<tabEnabled public="1"><e path="Bool"/></tabEnabled>
		<tabIndex public="1"><c path="Int"/></tabIndex>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<mouseChildren public="1"><e path="Bool"/></mouseChildren>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<tabChildren public="1"><e path="Bool"/></tabChildren>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<stopDrag public="1" set="method"><f a=""><e path="Void"/></f></stopDrag>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.StageAlign" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
	</enum>
	<class path="flash.display.Stage" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<align public="1"><e path="flash.display.StageAlign"/></align>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<frameRate public="1"><c path="Float"/></frameRate>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<showDefaultContextMenu public="1"><e path="Bool"/></showDefaultContextMenu>
		<stageFocusRect public="1"><e path="Bool"/></stageFocusRect>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<invalidate public="1" set="method"><f a=""><e path="Void"/></f></invalidate>
		<isFocusInaccessible public="1" set="method"><f a=""><e path="Bool"/></f></isFocusInaccessible>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<fullScreenHeight public="1" set="null"><t path="UInt"/></fullScreenHeight>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenWidth public="1" set="null"><t path="UInt"/></fullScreenWidth>
	</class>
	<class path="flash.xml.XML" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><e path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><e path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><e path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><c path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><e path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<e path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<e path="Void"/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<e path="Void"/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<name public="1" set="method"><f a=""><d/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<e path="Void"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<notification public="1" set="method"><f a=""><d/></f></notification>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setNotification public="1" set="method"><f a="f">
	<d/>
	<e path="Void"/>
</f></setNotification>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="format.abc.OpReader" params="" file="src/format/abc/OpReader.hx">
		<bytePos line="494" static="1"><c path="Int"/></bytePos>
		<jumps static="1"><c path="Array"><c path="Array"><c path="String"/></c></c></jumps>
		<jumpNameIndex static="1"><c path="Int"/></jumpNameIndex>
		<labels static="1"><c path="Array"><c path="String"/></c></labels>
		<labelNameIndex static="1"><c path="Int"/></labelNameIndex>
		<ops static="1"><c path="Array"><e path="format.abc.OpCode"/></c></ops>
		<decode public="1" set="method" line="500" static="1"><f a="i">
	<c path="haxe.io.Input"/>
	<c path="Array"><e path="format.abc.OpCode"/></c>
</f></decode>
		<i public="1"><c path="haxe.io.Input"/></i>
		<readInt public="1" set="method" line="40"><f a=""><c path="Int"/></f></readInt>
		<readIndex params="T" get="inline" set="null" line="63"><f a=""><e path="format.abc.Index"><c path="readIndex.T"/></e></f></readIndex>
		<readInt32 public="1" set="method" line="67"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<reg get="inline" set="null" line="91"><f a=""><c path="Int"/></f></reg>
		<jmp set="method" line="96"><f a="j">
	<e path="format.abc.JumpStyle"/>
	<e path="format.abc.OpCode"/>
</f></jmp>
		<readOp public="1" set="method" line="118"><f a="op">
	<c path="Int"/>
	<e path="format.abc.OpCode"/>
</f></readOp>
		<new public="1" set="method" line="36"><f a="i">
	<c path="haxe.io.Input"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="be.haxer.hxswfml.SwfWriter" params="" file="src/be/haxer/hxswfml/SwfWriter.hx">
		<main public="1" set="method" line="50" static="1"><f a=""><e path="Void"/></f></main>
		<currentTag><c path="Xml"/></currentTag>
		<validBaseClasses><c path="Array"><c path="String"/></c></validBaseClasses>
		<validElements><c path="Hash"><c path="Array"><c path="String"/></c></c></validElements>
		<validChildren><c path="Hash"><c path="Array"><c path="String"/></c></c></validChildren>
		<swcClasses><c path="Array"><c path="Array"><c path="String"/></c></c></swcClasses>
		<bitmapIds><c path="Array"><c path="Array"><c path="Int"/></c></c></bitmapIds>
		<dictionary><c path="Array"><c path="String"/></c></dictionary>
		<strict><e path="Bool"/></strict>
		<library public="1"><c path="Hash"><d/></c></library>
		<xml2swf public="1" set="method" line="66"><f a="input:fileOut">
	<c path="String"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></xml2swf>
		<createSWF set="method" line="122"><f a="xml:swfWriter">
	<c path="Xml"/>
	<a>
		<writeTag><f a="">
	<e path="format.swf.SWFTag"/>
	<e path="Void"/>
</f></writeTag>
		<writeHeader><f a="">
	<a>
		<width><t path="Null"><c path="Int"/></t></width>
		<version><t path="Null"><c path="Int"/></t></version>
		<nframes><t path="Null"><c path="Int"/></t></nframes>
		<height><t path="Null"><c path="Int"/></t></height>
		<fps><t path="Null"><c path="Int"/></t></fps>
		<compressed><t path="Null"><e path="Bool"/></t></compressed>
	</a>
	<e path="Void"/>
</f></writeHeader>
		<writeEnd><f a=""><e path="Void"/></f></writeEnd>
	</a>
	<e path="Void"/>
</f></createSWF>
		<header set="method" line="164"><f a=""><a>
	<width><t path="Null"><c path="Int"/></t></width>
	<version><t path="Null"><c path="Int"/></t></version>
	<nframes><t path="Null"><c path="Int"/></t></nframes>
	<height><t path="Null"><c path="Int"/></t></height>
	<fps><t path="Null"><c path="Int"/></t></fps>
	<compressed><t path="Null"><e path="Bool"/></t></compressed>
</a></f></header>
		<fileAttributes set="method" line="176"><f a=""><e path="format.swf.SWFTag"/></f></fileAttributes>
		<setBackgroundColor set="method" line="188"><f a=""><e path="format.swf.SWFTag"/></f></setBackgroundColor>
		<scriptLimits set="method" line="192"><f a=""><e path="format.swf.SWFTag"/></f></scriptLimits>
		<defineBitsJPEG set="method" line="199"><f a=""><e path="format.swf.SWFTag"/></f></defineBitsJPEG>
		<defineShape set="method" line="207"><f a=""><e path="format.swf.SWFTag"/></f></defineShape>
		<defineSprite set="method" line="407"><f a=""><e path="format.swf.SWFTag"/></f></defineSprite>
		<defineButton2 set="method" line="435"><f a=""><e path="format.swf.SWFTag"/></f></defineButton2>
		<defineSound set="method" line="474"><f a=""><e path="format.swf.SWFTag"/></f></defineSound>
		<defineBinaryData set="method" line="520"><f a=""><e path="format.swf.SWFTag"/></f></defineBinaryData>
		<defineFont set="method" line="527"><f a=""><e path="format.swf.SWFTag"/></f></defineFont>
		<defineEditText set="method" line="550"><f a=""><e path="format.swf.SWFTag"/></f></defineEditText>
		<defineABC set="method" line="603"><f a=""><c path="Array"><e path="format.swf.SWFTag"/></c></f></defineABC>
		<defineScalingGrid set="method" line="683"><f a=""><e path="format.swf.SWFTag"/></f></defineScalingGrid>
		<placeObject2 set="method" line="694"><f a=""><e path="format.swf.SWFTag"/></f></placeObject2>
		<moveObject set="method" line="719"><f a="depth:x:y:scaleX:scaleY:rs0:rs1">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="Null"><c path="Float"/></t>
	<t path="Null"><c path="Float"/></t>
	<t path="Null"><c path="Float"/></t>
	<t path="Null"><c path="Float"/></t>
	<e path="format.swf.SWFTag"/>
</f></moveObject>
		<tween set="method" line="764"><f a=""><c path="Array"><e path="format.swf.SWFTag"/></c></f></tween>
		<removeObject2 set="method" line="850"><f a=""><e path="format.swf.SWFTag"/></f></removeObject2>
		<startSound set="method" line="855"><f a=""><e path="format.swf.SWFTag"/></f></startSound>
		<symbolClass set="method" line="863"><f a=""><c path="Array"><e path="format.swf.SWFTag"/></c></f></symbolClass>
		<exportAssets set="method" line="888"><f a=""><c path="Array"><e path="format.swf.SWFTag"/></c></f></exportAssets>
		<metadata set="method" line="895"><f a=""><e path="format.swf.SWFTag"/></f></metadata>
		<frameLabel set="method" line="902"><f a=""><e path="format.swf.SWFTag"/></f></frameLabel>
		<showFrame set="method" line="909"><f a=""><e path="format.swf.SWFTag"/></f></showFrame>
		<endFrame set="method" line="914"><f a=""><e path="format.swf.SWFTag"/></f></endFrame>
		<custom set="method" line="918"><f a=""><e path="format.swf.SWFTag"/></f></custom>
		<storeWidthHeight set="method" line="941"><f a="id:fileName:b">
	<c path="Int"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></storeWidthHeight>
		<createABC set="method" line="993"><f a="className:baseClass">
	<c path="String"/>
	<c path="String"/>
	<e path="format.swf.SWFTag"/>
</f></createABC>
		<getContent set="method" line="1046"><f a="file">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<getBytes set="method" line="1067"><f a="file">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<getInt set="method" line="1089"><f a="att:defaultValue:?required:?uniqueId:?targetId">
	<c path="String"/>
	<t path="Null"><c path="Int"/></t>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="Null"><c path="Int"/></t>
</f></getInt>
		<getBool set="method" line="1103"><f a="att:defaultValue:?required">
	<c path="String"/>
	<t path="Null"><e path="Bool"/></t>
	<e path="Bool"/>
	<t path="Null"><e path="Bool"/></t>
</f></getBool>
		<getFloat set="method" line="1110"><f a="att:defaultValue:?required">
	<c path="String"/>
	<t path="Null"><c path="Float"/></t>
	<e path="Bool"/>
	<t path="Null"><c path="Float"/></t>
</f></getFloat>
		<getString set="method" line="1120"><f a="att:defaultValue:?required">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getString>
		<getMatrix set="method" line="1127"><f a=""><a>
	<translate><a>
	<y><c path="Int"/></y>
	<x><c path="Int"/></x>
</a></translate>
	<scale><a>
	<y><t path="Null"><c path="Float"/></t></y>
	<x><t path="Null"><c path="Float"/></t></x>
</a></scale>
	<rotate><a>
	<rs1><t path="Null"><c path="Float"/></t></rs1>
	<rs0><t path="Null"><c path="Float"/></t></rs0>
</a></rotate>
</a></f></getMatrix>
		<checkDictionary set="method" line="1145"><f a="id">
	<c path="Int"/>
	<e path="Void"/>
</f></checkDictionary>
		<checkTargetId set="method" line="1160"><f a="id">
	<c path="Int"/>
	<e path="Void"/>
</f></checkTargetId>
		<checkFileExistence set="method" line="1204"><f a="file">
	<c path="String"/>
	<e path="Void"/>
</f></checkFileExistence>
		<setup set="method" line="1234"><f a=""><e path="Void"/></f></setup>
		<checkUnknownAttributes set="method" line="1291"><f a=""><e path="Void"/></f></checkUnknownAttributes>
		<checkValidAttribute set="method" line="1304"><f a="a">
	<c path="String"/>
	<e path="Bool"/>
</f></checkValidAttribute>
		<checkValidBaseClass set="method" line="1315"><f a="c">
	<c path="String"/>
	<e path="Bool"/>
</f></checkValidBaseClass>
		<createXML set="method" line="1324"><f a="mod">
	<c path="Float"/>
	<c path="String"/>
</f></createXML>
		<error set="method" line="1359"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></error>
		<inform set="method" line="1363"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></inform>
		<new public="1" set="method" line="54"><f a="?strict">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
* 
* @author Jan J. Flanders
</haxe_doc>
	</class>
	<class path="format.mp3.Tools" params="" file="src/format/mp3/Tools.hx">
		<getBitrate public="1" set="method" line="40" static="1">
			<f a="mpegVersion:layerIdx:bitrateIdx">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="format.mp3.Bitrate"/>
			</f>
			<haxe_doc>
    * Returns kbps
    </haxe_doc>
		</getBitrate>
		<getSamplingRate public="1" set="method" line="50" static="1">
			<f a="mpegVersion:samplingRateIdx">
				<c path="Int"/>
				<c path="Int"/>
				<e path="format.mp3.SamplingRate"/>
			</f>
			<haxe_doc>
    * Returns Hz
    </haxe_doc>
		</getSamplingRate>
		<isInvalidFrameHeader public="1" set="method" line="57" static="1">
			<f a="hdr">
				<t path="format.mp3.MP3Header"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
    * Tells whether the header is invalid.
    </haxe_doc>
		</isInvalidFrameHeader>
		<getSampleDataSize public="1" set="method" line="74" static="1">
			<f a="mpegVersion:bitrate:samplingRate:isPadded:hasCrc">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
    * Return sample data size. Note that
    * the 4 bytes subtracted is the size of the header,
    * so this 4 bytes less the frame size.
    *
    * Also, 2 bytes are subtracted for CRC too, if present
    </haxe_doc>
		</getSampleDataSize>
		<getSampleDataSizeHdr public="1" set="method" line="78" static="1"><f a="hdr">
	<t path="format.mp3.MP3Header"/>
	<c path="Int"/>
</f></getSampleDataSizeHdr>
		<getSampleCount public="1" set="method" line="89" static="1">
			<f a="mpegVersion">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
    * Returns the number of samples in the frame.
    </haxe_doc>
		</getSampleCount>
		<getSampleCountHdr public="1" set="method" line="94" static="1"><f a="hdr">
	<t path="format.mp3.MP3Header"/>
	<c path="Int"/>
</f></getSampleCountHdr>
		<getFrameInfo public="1" set="method" line="102" static="1">
			<f a="fr">
				<t path="format.mp3.MP3Frame"/>
				<c path="String"/>
			</f>
			<haxe_doc>
    * Displays frame info in human-readable format.
    * Subject to change, do not use for programmatical parsing!
    </haxe_doc>
		</getFrameInfo>
	</class>
	<class path="format.zip.Reader" params="" file="src/format/zip/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<readZipDate set="method" line="40"><f a=""><c path="Date"/></f></readZipDate>
		<readExtraFields set="method" line="52"><f a="length">
	<c path="Int"/>
	<c path="List"><e path="format.zip.ExtraField"/></c>
</f></readExtraFields>
		<readEntryHeader public="1" set="method" line="80"><f a=""><t path="format.zip.Entry"/></f></readEntryHeader>
		<readEntryData public="1" set="method" line="122"><f a="e:buf:out">
	<t path="format.zip.Entry"/>
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Output"/>
	<e path="Void"/>
</f></readEntryData>
		<read public="1" set="method" line="126"><f a=""><t path="format.zip.Data"/></f></read>
		<new public="1" set="method" line="36"><f a="i">
	<c path="haxe.io.Input"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundTransform" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/media/SoundTransform.hx" extern="1">
		<leftToLeft public="1"><c path="Float"/></leftToLeft>
		<leftToRight public="1"><c path="Float"/></leftToRight>
		<pan public="1"><c path="Float"/></pan>
		<rightToLeft public="1"><c path="Float"/></rightToLeft>
		<rightToRight public="1"><c path="Float"/></rightToRight>
		<volume public="1"><c path="Float"/></volume>
		<new public="1" set="method"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.Graphics" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/Graphics.hx" extern="1">
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.text.TextField" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<alwaysShowSelection public="1"><e path="Bool"/></alwaysShowSelection>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<background public="1"><e path="Bool"/></background>
		<backgroundColor public="1"><t path="UInt"/></backgroundColor>
		<border public="1"><e path="Bool"/></border>
		<borderColor public="1"><t path="UInt"/></borderColor>
		<bottomScrollV public="1" set="null"><c path="Int"/></bottomScrollV>
		<caretIndex public="1" set="null"><c path="Int"/></caretIndex>
		<condenseWhite public="1"><e path="Bool"/></condenseWhite>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1"><e path="Bool"/></displayAsPassword>
		<embedFonts public="1"><e path="Bool"/></embedFonts>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<htmlText public="1"><c path="String"/></htmlText>
		<length public="1" set="null"><c path="Int"/></length>
		<maxChars public="1"><c path="Int"/></maxChars>
		<maxScrollH public="1" set="null"><c path="Int"/></maxScrollH>
		<maxScrollV public="1" set="null"><c path="Int"/></maxScrollV>
		<mouseWheelEnabled public="1"><e path="Bool"/></mouseWheelEnabled>
		<multiline public="1"><e path="Bool"/></multiline>
		<numLines public="1" set="null"><c path="Int"/></numLines>
		<restrict public="1"><c path="String"/></restrict>
		<scrollH public="1"><c path="Int"/></scrollH>
		<scrollV public="1"><c path="Int"/></scrollV>
		<selectable public="1"><e path="Bool"/></selectable>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectionBeginIndex public="1" set="null"><c path="Int"/></selectionBeginIndex>
		<selectionEndIndex public="1" set="null"><c path="Int"/></selectionEndIndex>
		<sharpness public="1"><c path="Float"/></sharpness>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<text public="1"><c path="String"/></text>
		<textColor public="1"><t path="UInt"/></textColor>
		<textHeight public="1" set="null"><c path="Float"/></textHeight>
		<textWidth public="1" set="null"><c path="Float"/></textWidth>
		<thickness public="1"><c path="Float"/></thickness>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<useRichTextClipboard public="1"><e path="Bool"/></useRichTextClipboard>
		<wordWrap public="1"><e path="Bool"/></wordWrap>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getCharIndexAtPoint>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getFirstCharInParagraph>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getLineIndexAtPoint>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineIndexOfChar>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineLength>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getParagraphLength>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></insertXMLText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceText>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.LineScaleMode" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
	</enum>
	<class path="flash.display.Loader" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></load>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></loadBytes>
		<unload public="1" set="method"><f a=""><e path="Void"/></f></unload>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/ui/ContextMenuBuiltInItems.hx" extern="1">
		<forwardAndBack public="1"><e path="Bool"/></forwardAndBack>
		<loop public="1"><e path="Bool"/></loop>
		<play public="1"><e path="Bool"/></play>
		<print public="1"><e path="Bool"/></print>
		<quality public="1"><e path="Bool"/></quality>
		<rewind public="1"><e path="Bool"/></rewind>
		<save public="1"><e path="Bool"/></save>
		<zoom public="1"><e path="Bool"/></zoom>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.io.Input" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/Input.hx">
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<readByte public="1" set="method" line="35"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="44"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="65"><f a=""><e path="Void"/></f></close>
		<setEndian set="method" line="68"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<readAll public="1" set="method" line="75"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<readFullBytes public="1" set="method" line="96"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<read public="1" set="method" line="104"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readUntil public="1" set="method" line="116"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<readLine public="1" set="method" line="124"><f a=""><c path="String"/></f></readLine>
		<readFloat public="1" set="method" line="141"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="155"><f a=""><c path="Float"/></f></readDouble>
		<readInt8 public="1" set="method" line="169"><f a=""><c path="Int"/></f></readInt8>
		<readInt16 public="1" set="method" line="176"><f a=""><c path="Int"/></f></readInt16>
		<readUInt16 public="1" set="method" line="185"><f a=""><c path="Int"/></f></readUInt16>
		<readInt24 public="1" set="method" line="191"><f a=""><c path="Int"/></f></readInt24>
		<readUInt24 public="1" set="method" line="201"><f a=""><c path="Int"/></f></readUInt24>
		<readInt31 public="1" set="method" line="208"><f a=""><c path="Int"/></f></readInt31>
		<readUInt30 public="1" set="method" line="225"><f a=""><c path="Int"/></f></readUInt30>
		<readInt32 public="1" set="method" line="234"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readString public="1" set="method" line="242"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>
	An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.
</haxe_doc>
	</class>
	<class path="haxe.io.BytesInput" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<readByte public="1" set="method" line="56" override="1"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="75" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<setEndian set="method" line="105" override="1"><f a="e">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<readFloat public="1" set="method" line="111" override="1"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="115" override="1"><f a=""><c path="Float"/></f></readDouble>
		<readInt8 public="1" set="method" line="119" override="1"><f a=""><c path="Int"/></f></readInt8>
		<readInt16 public="1" set="method" line="123" override="1"><f a=""><c path="Int"/></f></readInt16>
		<readUInt16 public="1" set="method" line="127" override="1"><f a=""><c path="Int"/></f></readUInt16>
		<readInt31 public="1" set="method" line="131" override="1"><f a=""><c path="Int"/></f></readInt31>
		<readUInt30 public="1" set="method" line="138" override="1"><f a=""><c path="Int"/></f></readUInt30>
		<readInt32 public="1" set="method" line="145" override="1"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readString public="1" set="method" line="149" override="1"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<new public="1" set="method" line="35"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Eof" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	This exception is raised when reading while data is no longer available in the [Input].
</haxe_doc>
	</class>
	<class path="flash.Error" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/Error.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<c path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<c path="Class"><d/></c>
	<t path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<new public="1" set="method"><f a="?message:?id">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Class" params="T" file="C:\Program Files\Motion-Twin\haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="Reflect" params="" file="C:\Program Files\Motion-Twin\haxe/std/Reflect.hx">
		<hasField public="1" set="method" line="35" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" get="inline" set="null" line="61" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="87" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" get="inline" set="null" line="106" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="135" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="210" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="231" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="243" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
		Does not work on Neko platform.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="275" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="319" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="349" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="372" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="flash.xml.XMLList" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/xml/XMLList.hx" extern="1">
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<e path="Void"/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<e path="Void"/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<name public="1" set="method"><f a=""><d/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<e path="Void"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="format.mp3.SamplingRate" params="" file="src/format/mp3/Data.hx" module="format.mp3.Data">
		<SR_Bad/>
		<SR_8000/>
		<SR_48000/>
		<SR_44100/>
		<SR_32000/>
		<SR_24000/>
		<SR_22050/>
		<SR_12000/>
		<SR_11025/>
	</enum>
	<enum path="format.mp3.Bitrate" params="" file="src/format/mp3/Data.hx" module="format.mp3.Data">
		<BR_Free/>
		<BR_Bad/>
		<BR_96/>
		<BR_80/>
		<BR_8/>
		<BR_64/>
		<BR_56/>
		<BR_48/>
		<BR_448/>
		<BR_416/>
		<BR_40/>
		<BR_384/>
		<BR_352/>
		<BR_320/>
		<BR_32/>
		<BR_288/>
		<BR_256/>
		<BR_24/>
		<BR_224/>
		<BR_192/>
		<BR_176/>
		<BR_160/>
		<BR_16/>
		<BR_144/>
		<BR_128/>
		<BR_112/>
	</enum>
	<class path="format.mp3.MPEG" params="" file="src/format/mp3/Constants.hx" module="format.mp3.Constants">
		<V1 public="1" line="11" static="1"><c path="Int"/></V1>
		<V2 public="1" line="12" static="1"><c path="Int"/></V2>
		<V25 public="1" line="13" static="1"><c path="Int"/></V25>
		<Reserved public="1" line="14" static="1"><c path="Int"/></Reserved>
		<enum2Num public="1" set="method" line="16" static="1"><f a="m">
	<e path="format.mp3.MPEGVersion"/>
	<c path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="25" static="1"><f a="m">
	<c path="Int"/>
	<e path="format.mp3.MPEGVersion"/>
</f></num2Enum>
		<V1_Bitrates public="1" line="35" static="1"><c path="Array"><c path="Array"><e path="format.mp3.Bitrate"/></c></c></V1_Bitrates>
		<V2_Bitrates public="1" line="43" static="1"><c path="Array"><c path="Array"><e path="format.mp3.Bitrate"/></c></c></V2_Bitrates>
		<SamplingRates public="1" line="51" static="1"><c path="Array"><c path="Array"><e path="format.mp3.SamplingRate"/></c></c></SamplingRates>
		<srNum2Enum public="1" set="method" line="58" static="1"><f a="sr">
	<c path="Int"/>
	<e path="format.mp3.SamplingRate"/>
</f></srNum2Enum>
		<srEnum2Num public="1" set="method" line="72" static="1"><f a="sr">
	<e path="format.mp3.SamplingRate"/>
	<c path="Int"/>
</f></srEnum2Num>
		<getBitrateIdx public="1" set="method" line="87" static="1"><f a="br:mpeg:layer">
	<e path="format.mp3.Bitrate"/>
	<e path="format.mp3.MPEGVersion"/>
	<e path="format.mp3.Layer"/>
	<c path="Int"/>
</f></getBitrateIdx>
		<getSamplingRateIdx public="1" set="method" line="96" static="1"><f a="sr:mpeg">
	<e path="format.mp3.SamplingRate"/>
	<e path="format.mp3.MPEGVersion"/>
	<c path="Int"/>
</f></getSamplingRateIdx>
		<bitrateEnum2Num public="1" set="method" line="105" static="1"><f a="br">
	<e path="format.mp3.Bitrate"/>
	<c path="Int"/>
</f></bitrateEnum2Num>
		<bitrateNum2Enum public="1" set="method" line="136" static="1"><f a="br">
	<c path="Int"/>
	<e path="format.mp3.Bitrate"/>
</f></bitrateNum2Enum>
		<haxe_doc>
 * MPEG Version
 *
 * sored on 2 bits in the file,
 * values represent bit values
 </haxe_doc>
	</class>
	<class path="format.mp3.CLayer" params="" file="src/format/mp3/Constants.hx" module="format.mp3.Constants">
		<LReserved public="1" line="177" static="1"><c path="Int"/></LReserved>
		<LLayer3 public="1" line="178" static="1"><c path="Int"/></LLayer3>
		<LLayer2 public="1" line="179" static="1"><c path="Int"/></LLayer2>
		<LLayer1 public="1" line="180" static="1"><c path="Int"/></LLayer1>
		<enum2Num public="1" set="method" line="182" static="1"><f a="l">
	<e path="format.mp3.Layer"/>
	<c path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="191" static="1"><f a="l">
	<c path="Int"/>
	<e path="format.mp3.Layer"/>
</f></num2Enum>
		<haxe_doc>
 * Layer
 *
 * stored on 2 bits in the file,
 * values represent bit values
 </haxe_doc>
	</class>
	<class path="format.mp3.CChannelMode" params="" file="src/format/mp3/Constants.hx" module="format.mp3.Constants">
		<CStereo public="1" get="inline" set="null" line="209" static="1"><c path="Int"/></CStereo>
		<CJointStereo public="1" get="inline" set="null" line="210" static="1"><c path="Int"/></CJointStereo>
		<CDualChannel public="1" line="211" static="1"><c path="Int"/></CDualChannel>
		<CMono public="1" line="212" static="1"><c path="Int"/></CMono>
		<enum2Num public="1" set="method" line="214" static="1"><f a="c">
	<e path="format.mp3.ChannelMode"/>
	<c path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="223" static="1"><f a="c">
	<c path="Int"/>
	<e path="format.mp3.ChannelMode"/>
</f></num2Enum>
		<haxe_doc>
 * Sound channel mode
 *
 * stored on 2 bits in the file,
 * values represent bit values
 </haxe_doc>
	</class>
	<class path="format.mp3.CEmphasis" params="" file="src/format/mp3/Constants.hx" module="format.mp3.Constants">
		<ENone public="1" get="inline" set="null" line="239" static="1"><c path="Int"/></ENone>
		<EMs50_15 public="1" get="inline" set="null" line="240" static="1"><c path="Int"/></EMs50_15>
		<EReserved public="1" get="inline" set="null" line="241" static="1"><c path="Int"/></EReserved>
		<ECCIT_J17 public="1" get="inline" set="null" line="242" static="1"><c path="Int"/></ECCIT_J17>
		<enum2Num public="1" set="method" line="244" static="1"><f a="c">
	<e path="format.mp3.Emphasis"/>
	<c path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="253" static="1"><f a="c">
	<c path="Int"/>
	<e path="format.mp3.Emphasis"/>
</f></num2Enum>
		<haxe_doc>
 * Emphasis
 *
 * 2 bits
 </haxe_doc>
	</class>
	<typedef path="format.swf.ShapeStyleInfo" params="" file="src/format/swf/Writer.hx" module="format.swf.Writer"><a>
	<numLineStyles><c path="Int"/></numLineStyles>
	<numFillStyles><c path="Int"/></numFillStyles>
	<lineBits><c path="Int"/></lineBits>
	<fillBits><c path="Int"/></fillBits>
</a></typedef>
	<class path="format.swf.Writer" params="" file="src/format/swf/Writer.hx">
		<output><c path="haxe.io.Output"/></output>
		<o><c path="haxe.io.BytesOutput"/></o>
		<compressed><e path="Bool"/></compressed>
		<bits><c path="format.tools.BitsOutput"/></bits>
		<write public="1" set="method" line="56"><f a="s">
	<t path="format.swf.SWF"/>
	<e path="Void"/>
</f></write>
		<writeRect set="method" line="63"><f a="r">
	<a>
		<top><c path="Int"/></top>
		<right><c path="Int"/></right>
		<left><c path="Int"/></left>
		<bottom><c path="Int"/></bottom>
	</a>
	<e path="Void"/>
</f></writeRect>
		<writeFixed8 get="inline" set="null" line="74"><f a="v">
	<c path="Int"/>
	<e path="Void"/>
</f></writeFixed8>
		<writeFixed get="inline" set="null" line="78"><f a="v">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeFixed>
		<openTMP set="method" line="82"><f a=""><c path="haxe.io.BytesOutput"/></f></openTMP>
		<closeTMP set="method" line="89"><f a="old">
	<c path="haxe.io.BytesOutput"/>
	<c path="haxe.io.Bytes"/>
</f></closeTMP>
		<writeHeader public="1" set="method" line="96"><f a="h">
	<t path="format.swf.SWFHeader"/>
	<e path="Void"/>
</f></writeHeader>
		<writeRGB set="method" line="113"><f a="c">
	<t path="format.swf.RGB"/>
	<e path="Void"/>
</f></writeRGB>
		<writeRGBA set="method" line="119"><f a="c">
	<t path="format.swf.RGBA"/>
	<e path="Void"/>
</f></writeRGBA>
		<writeMatrix set="method" line="126"><f a="m">
	<t path="format.swf.Matrix"/>
	<e path="Void"/>
</f></writeMatrix>
		<writeCXAColor set="method" line="165"><f a="c:nbits">
	<t path="format.swf.RGBA"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeCXAColor>
		<writeCXA set="method" line="172"><f a="c">
	<t path="format.swf.CXA"/>
	<e path="Void"/>
</f></writeCXA>
		<writeClipEvents set="method" line="181"><f a="events">
	<c path="Array"><t path="format.swf.ClipEvent"/></c>
	<e path="Void"/>
</f></writeClipEvents>
		<writeFilterFlags set="method" line="195"><f a="f:top">
	<t path="format.swf.FilterFlags"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></writeFilterFlags>
		<writeFilterGradient set="method" line="204"><f a="f">
	<t path="format.swf.GradientFilterData"/>
	<e path="Void"/>
</f></writeFilterGradient>
		<writeFilter set="method" line="219"><f a="f">
	<e path="format.swf.Filter"/>
	<e path="Void"/>
</f></writeFilter>
		<writeFilters set="method" line="265"><f a="filters">
	<c path="Array"><e path="format.swf.Filter"/></c>
	<e path="Void"/>
</f></writeFilters>
		<writeBlendMode set="method" line="271"><f a="b">
	<e path="format.swf.BlendMode"/>
	<e path="Void"/>
</f></writeBlendMode>
		<writePlaceObject set="method" line="275"><f a="po:v3">
	<c path="format.swf.PlaceObject"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></writePlaceObject>
		<writeTID set="method" line="310"><f a="id:len">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeTID>
		<writeTIDExt set="method" line="320"><f a="id:len">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeTIDExt>
		<writeSymbols set="method" line="325"><f a="sl:tagid">
	<c path="Array"><t path="format.swf.SymData"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></writeSymbols>
		<writeSound set="method" line="338"><f a="s">
	<t path="format.swf.Sound"/>
	<e path="Void"/>
</f></writeSound>
		<writeGradRecord set="method" line="377"><f a="ver:grad_record">
	<c path="Int"/>
	<e path="format.swf.GradRecord"/>
	<e path="Void"/>
</f></writeGradRecord>
		<writeGradient set="method" line="393"><f a="ver:grad">
	<c path="Int"/>
	<t path="format.swf.Gradient"/>
	<e path="Void"/>
</f></writeGradient>
		<writeFocalGradient set="method" line="427"><f a="ver:grad">
	<c path="Int"/>
	<t path="format.swf.FocalGradient"/>
	<e path="Void"/>
</f></writeFocalGradient>
		<writeFillStyle set="method" line="435"><f a="ver:fill_style">
	<c path="Int"/>
	<e path="format.swf.FillStyle"/>
	<e path="Void"/>
</f></writeFillStyle>
		<writeFillStyles set="method" line="484"><f a="ver:fill_styles">
	<c path="Int"/>
	<c path="Array"><e path="format.swf.FillStyle"/></c>
	<e path="Void"/>
</f></writeFillStyles>
		<writeLineStyle set="method" line="505"><f a="ver:line_style">
	<c path="Int"/>
	<t path="format.swf.LineStyle"/>
	<e path="Void"/>
</f></writeLineStyle>
		<writeLineStyles set="method" line="564"><f a="ver:line_styles">
	<c path="Int"/>
	<c path="Array"><t path="format.swf.LineStyle"/></c>
	<e path="Void"/>
</f></writeLineStyles>
		<writeShapeRecord set="method" line="585"><f a="ver:style_info:shape_record">
	<c path="Int"/>
	<t path="format.swf.ShapeStyleInfo"/>
	<e path="format.swf.ShapeRecord"/>
	<e path="Void"/>
</f></writeShapeRecord>
		<writeShapeWithoutStyle set="method" line="678"><f a="ver:data">
	<c path="Int"/>
	<t path="format.swf.ShapeWithoutStyleData"/>
	<e path="Void"/>
</f></writeShapeWithoutStyle>
		<writeShapeWithStyle set="method" line="696"><f a="ver:data">
	<c path="Int"/>
	<t path="format.swf.ShapeWithStyleData"/>
	<e path="Void"/>
</f></writeShapeWithStyle>
		<writeShape public="1" set="method" line="717"><f a="id:data">
	<c path="Int"/>
	<e path="format.swf.ShapeData"/>
	<e path="Void"/>
</f></writeShape>
		<writeMorphGradient set="method" line="766"><f a="ver:g">
	<c path="Int"/>
	<t path="format.swf.MorphGradient"/>
	<e path="Void"/>
</f></writeMorphGradient>
		<writeMorphGradients set="method" line="773"><f a="ver:gradients">
	<c path="Int"/>
	<c path="Array"><t path="format.swf.MorphGradient"/></c>
	<e path="Void"/>
</f></writeMorphGradients>
		<writeMorphFillStyle set="method" line="783"><f a="ver:fill_style">
	<c path="Int"/>
	<e path="format.swf.MorphFillStyle"/>
	<e path="Void"/>
</f></writeMorphFillStyle>
		<writeMorphFillStyles set="method" line="818"><f a="ver:fill_styles">
	<c path="Int"/>
	<c path="Array"><e path="format.swf.MorphFillStyle"/></c>
	<e path="Void"/>
</f></writeMorphFillStyles>
		<writeMorph1LineStyle set="method" line="834"><f a="s">
	<t path="format.swf.Morph1LineStyle"/>
	<e path="Void"/>
</f></writeMorph1LineStyle>
		<writeMorph1LineStyles set="method" line="841"><f a="line_styles">
	<c path="Array"><t path="format.swf.Morph1LineStyle"/></c>
	<e path="Void"/>
</f></writeMorph1LineStyles>
		<writeMorph2LineStyle set="method" line="857"><f a="style">
	<e path="format.swf.Morph2LineStyle"/>
	<e path="Void"/>
</f></writeMorph2LineStyle>
		<writeMorph2LineStyles set="method" line="918"><f a="line_styles">
	<c path="Array"><e path="format.swf.Morph2LineStyle"/></c>
	<e path="Void"/>
</f></writeMorph2LineStyles>
		<writeMorphShape public="1" set="method" line="934"><f a="id:data">
	<c path="Int"/>
	<e path="format.swf.MorphShapeData"/>
	<e path="Void"/>
</f></writeMorphShape>
		<writeFontGlyphs set="method" line="996"><f a="glyphs">
	<c path="Array"><t path="format.swf.ShapeWithoutStyleData"/></c>
	<c path="Array"><c path="Int"/></c>
</f></writeFontGlyphs>
		<writeFont1 set="method" line="1021"><f a="data">
	<t path="format.swf.Font1Data"/>
	<e path="Void"/>
</f></writeFont1>
		<writeFont2 set="method" line="1040"><f a="hasWideChars:data">
	<e path="Bool"/>
	<t path="format.swf.Font2Data"/>
	<e path="Void"/>
</f></writeFont2>
		<writeFont public="1" set="method" line="1137"><f a="id:data">
	<c path="Int"/>
	<e path="format.swf.FontData"/>
	<e path="Void"/>
</f></writeFont>
		<writeFontInfo public="1" set="method" line="1170"><f a="id:data">
	<c path="Int"/>
	<e path="format.swf.FontInfoData"/>
	<e path="Void"/>
</f></writeFontInfo>
		<writeSoundInfo set="method" line="1225"><f a="info">
	<t path="format.swf.SoundInfo"/>
	<e path="Void"/>
</f></writeSoundInfo>
		<writeEnvelopeRecords set="method" line="1238"><f a="soundEnvelopes">
	<c path="Array"><t path="format.swf.SoundEnvelope"/></c>
	<e path="Void"/>
</f></writeEnvelopeRecords>
		<writeFileAttributes set="method" line="1247"><f a="att">
	<t path="format.swf.FileAttributes"/>
	<e path="Void"/>
</f></writeFileAttributes>
		<writeButtonRecord set="method" line="1258"><f a="btnRec">
	<t path="format.swf.ButtonRecord"/>
	<e path="Void"/>
</f></writeButtonRecord>
		<writeDefineEditText set="method" line="1270"><f a="data">
	<t path="format.swf.TextFieldData"/>
	<e path="Void"/>
</f></writeDefineEditText>
		<writeTag public="1" set="method" line="1321"><f a="t">
	<e path="format.swf.SWFTag"/>
	<e path="Void"/>
</f></writeTag>
		<writeEnd public="1" set="method" line="1530"><f a=""><e path="Void"/></f></writeEnd>
		<new public="1" set="method" line="52"><f a="o">
	<c path="haxe.io.Output"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/text/TextSnapshot.hx" extern="1">
		<charCount public="1" set="null"><c path="Int"/></charCount>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getSelected>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<e path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getText>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></hitTestTextNearPos>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<t path="UInt"/>
	<e path="Void"/>
</f></setSelectColor>
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/geom/ColorTransform.hx" extern="1">
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<color public="1"><t path="UInt"/></color>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<redOffset public="1"><c path="Float"/></redOffset>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/geom/Rectangle.hx" extern="1">
		<bottom public="1"><c path="Float"/></bottom>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<height public="1"><c path="Float"/></height>
		<left public="1"><c path="Float"/></left>
		<right public="1"><c path="Float"/></right>
		<size public="1"><c path="flash.geom.Point"/></size>
		<top public="1"><c path="Float"/></top>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<contains public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<inflate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method"><f a=""><e path="Bool"/></f></isEmpty>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method"><f a=""><e path="Void"/></f></setEmpty>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="format.abc.Index" params="T" file="src/format/abc/Data.hx" module="format.abc.Data"><Idx a="v"><c path="Int"/></Idx></enum>
	<enum path="format.abc.Namespace" params="" file="src/format/abc/Data.hx" module="format.abc.Data">
		<NStaticProtected a="ns"><e path="format.abc.Index"><c path="String"/></e></NStaticProtected>
		<NPublic a="ns"><e path="format.abc.Index"><c path="String"/></e></NPublic>
		<NProtected a="ns"><e path="format.abc.Index"><c path="String"/></e></NProtected>
		<NPrivate a="ns"><e path="format.abc.Index"><c path="String"/></e></NPrivate>
		<NNamespace a="ns"><e path="format.abc.Index"><c path="String"/></e></NNamespace>
		<NInternal a="ns"><e path="format.abc.Index"><c path="String"/></e></NInternal>
		<NExplicit a="ns"><e path="format.abc.Index"><c path="String"/></e></NExplicit>
	</enum>
	<typedef path="format.abc.NamespaceSet" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><c path="Array"><e path="format.abc.Index"><e path="format.abc.Namespace"/></e></c></typedef>
	<enum path="format.abc.Name" params="" file="src/format/abc/Data.hx" module="format.abc.Data">
		<NRuntimeLate/>
		<NRuntime a="name"><e path="format.abc.Index"><c path="String"/></e></NRuntime>
		<NParams a="n:params">
			<t path="format.abc.IName"/>
			<c path="Array"><t path="format.abc.IName"/></c>
		</NParams>
		<NName a="name:ns">
			<e path="format.abc.Index"><c path="String"/></e>
			<e path="format.abc.Index"><e path="format.abc.Namespace"/></e>
		</NName>
		<NMultiLate a="nset"><e path="format.abc.Index"><t path="format.abc.NamespaceSet"/></e></NMultiLate>
		<NMulti a="name:ns">
			<e path="format.abc.Index"><c path="String"/></e>
			<e path="format.abc.Index"><t path="format.abc.NamespaceSet"/></e>
		</NMulti>
		<NAttrib a="n"><e path="format.abc.Name"/></NAttrib>
	</enum>
	<typedef path="format.abc.MethodType" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><a>
	<ret><t path="Null"><t path="format.abc.IName"/></t></ret>
	<extra><t path="Null"><t path="format.abc.MethodTypeExtra"/></t></extra>
	<args><c path="Array"><t path="Null"><t path="format.abc.IName"/></t></c></args>
</a></typedef>
	<typedef path="format.abc.MethodTypeExtra" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><a>
	<variableArgs><e path="Bool"/></variableArgs>
	<usesDXNS><e path="Bool"/></usesDXNS>
	<unused><e path="Bool"/></unused>
	<paramNames><t path="Null"><c path="Array"><t path="Null"><e path="format.abc.Index"><c path="String"/></e></t></c></t></paramNames>
	<newBlock><e path="Bool"/></newBlock>
	<native><e path="Bool"/></native>
	<defaultParameters><t path="Null"><c path="Array"><e path="format.abc.Value"/></c></t></defaultParameters>
	<debugName><t path="Null"><e path="format.abc.Index"><c path="String"/></e></t></debugName>
	<argumentsDefined><e path="Bool"/></argumentsDefined>
</a></typedef>
	<enum path="format.abc.Value" params="" file="src/format/abc/Data.hx" module="format.abc.Data">
		<VUInt a="i"><e path="format.abc.Index"><c path="haxe.Int32"/></e></VUInt>
		<VString a="i"><e path="format.abc.Index"><c path="String"/></e></VString>
		<VNull/>
		<VNamespace a="kind:ns">
			<c path="Int"/>
			<e path="format.abc.Index"><e path="format.abc.Namespace"/></e>
		</VNamespace>
		<VInt a="i"><e path="format.abc.Index"><c path="haxe.Int32"/></e></VInt>
		<VFloat a="f"><e path="format.abc.Index"><c path="Float"/></e></VFloat>
		<VBool a="b"><e path="Bool"/></VBool>
	</enum>
	<typedef path="format.abc.TryCatch" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><a>
	<variable><t path="Null"><t path="format.abc.IName"/></t></variable>
	<type><t path="Null"><t path="format.abc.IName"/></t></type>
	<start><c path="Int"/></start>
	<handle><c path="Int"/></handle>
	<end><c path="Int"/></end>
</a></typedef>
	<typedef path="format.abc.Function" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><a>
	<type><e path="format.abc.Index"><t path="format.abc.MethodType"/></e></type>
	<trys><c path="Array"><t path="format.abc.TryCatch"/></c></trys>
	<nRegs><c path="Int"/></nRegs>
	<maxStack><c path="Int"/></maxStack>
	<maxScope><c path="Int"/></maxScope>
	<locals><c path="Array"><t path="format.abc.Field"/></c></locals>
	<initScope><c path="Int"/></initScope>
	<code><c path="haxe.io.Bytes"/></code>
</a></typedef>
	<typedef path="format.abc.Field" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><a>
	<slot><t path="format.abc.Slot"/></slot>
	<name><t path="format.abc.IName"/></name>
	<metadatas><t path="Null"><c path="Array"><e path="format.abc.Index"><t path="format.abc.Metadata"/></e></c></t></metadatas>
	<kind><e path="format.abc.FieldKind"/></kind>
</a></typedef>
	<enum path="format.abc.MethodKind" params="" file="src/format/abc/Data.hx" module="format.abc.Data">
		<KSetter/>
		<KNormal/>
		<KGetter/>
	</enum>
	<enum path="format.abc.FieldKind" params="" file="src/format/abc/Data.hx" module="format.abc.Data">
		<FVar a="?type:?value:?_const">
			<t path="format.abc.IName"/>
			<e path="format.abc.Value"/>
			<e path="Bool"/>
		</FVar>
		<FMethod a="type:k:?isFinal:?isOverride">
			<e path="format.abc.Index"><t path="format.abc.MethodType"/></e>
			<e path="format.abc.MethodKind"/>
			<e path="Bool"/>
			<e path="Bool"/>
		</FMethod>
		<FFunction a="f"><e path="format.abc.Index"><t path="format.abc.MethodType"/></e></FFunction>
		<FClass a="c"><e path="format.abc.Index"><t path="format.abc.ClassDef"/></e></FClass>
	</enum>
	<typedef path="format.abc.ClassDef" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><a>
	<superclass><t path="Null"><t path="format.abc.IName"/></t></superclass>
	<statics><t path="Null"><e path="format.abc.Index"><t path="format.abc.MethodType"/></e></t></statics>
	<staticFields><c path="Array"><t path="format.abc.Field"/></c></staticFields>
	<name><t path="format.abc.IName"/></name>
	<isSealed><e path="Bool"/></isSealed>
	<isInterface><e path="Bool"/></isInterface>
	<isFinal><e path="Bool"/></isFinal>
	<interfaces><c path="Array"><t path="format.abc.IName"/></c></interfaces>
	<fields><c path="Array"><t path="format.abc.Field"/></c></fields>
	<constructor><t path="Null"><e path="format.abc.Index"><t path="format.abc.MethodType"/></e></t></constructor>
	<_namespace><t path="Null"><e path="format.abc.Index"><e path="format.abc.Namespace"/></e></t></_namespace>
</a></typedef>
	<typedef path="format.abc.Metadata" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><a>
	<name><e path="format.abc.Index"><c path="String"/></e></name>
	<data><c path="Array"><a>
	<v><e path="format.abc.Index"><c path="String"/></e></v>
	<n><t path="Null"><e path="format.abc.Index"><c path="String"/></e></t></n>
</a></c></data>
</a></typedef>
	<typedef path="format.abc.Init" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><a>
	<method><e path="format.abc.Index"><t path="format.abc.MethodType"/></e></method>
	<fields><c path="Array"><t path="format.abc.Field"/></c></fields>
</a></typedef>
	<class path="format.abc.ABCData" params="" file="src/format/abc/Data.hx" module="format.abc.Data">
		<ints public="1"><c path="Array"><c path="haxe.Int32"/></c></ints>
		<uints public="1"><c path="Array"><c path="haxe.Int32"/></c></uints>
		<floats public="1"><c path="Array"><c path="Float"/></c></floats>
		<strings public="1"><c path="Array"><c path="String"/></c></strings>
		<namespaces public="1"><c path="Array"><e path="format.abc.Namespace"/></c></namespaces>
		<nssets public="1"><c path="Array"><t path="format.abc.NamespaceSet"/></c></nssets>
		<names public="1"><c path="Array"><e path="format.abc.Name"/></c></names>
		<methodTypes public="1"><c path="Array"><t path="format.abc.MethodType"/></c></methodTypes>
		<metadatas public="1"><c path="Array"><t path="format.abc.Metadata"/></c></metadatas>
		<classes public="1"><c path="Array"><t path="format.abc.ClassDef"/></c></classes>
		<inits public="1"><c path="Array"><t path="format.abc.Init"/></c></inits>
		<functions public="1"><c path="Array"><t path="format.abc.Function"/></c></functions>
		<get public="1" params="T" set="method" line="164"><f a="t:i">
	<c path="Array"><c path="get.T"/></c>
	<e path="format.abc.Index"><c path="get.T"/></e>
	<c path="get.T"/>
</f></get>
		<new public="1" set="method" line="168"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="format.abc.IName" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><e path="format.abc.Index"><e path="format.abc.Name"/></e></typedef>
	<typedef path="format.abc.Slot" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><c path="Int"/></typedef>
	<typedef path="format.abc.Register" params="" file="src/format/abc/Data.hx" module="format.abc.Data"><c path="Int"/></typedef>
	<enum path="format.abc.OpCode" params="" file="src/format/abc/Data.hx" module="format.abc.Data">
		<OUnknown a="byte"><c path="Int"/></OUnknown>
		<OUndefined/>
		<OUIntRef a="v"><e path="format.abc.Index"><c path="haxe.Int32"/></e></OUIntRef>
		<OTypeof/>
		<OTrue/>
		<OToXmlAttr/>
		<OToXml/>
		<OToUInt/>
		<OToString/>
		<OToObject/>
		<OToNumber/>
		<OToInt/>
		<OToBool/>
		<OTimestamp/>
		<OThrow/>
		<OThis/>
		<OSwitch a="def:deltas">
			<c path="Int"/>
			<c path="Array"><c path="Int"/></c>
		</OSwitch>
		<OSwap/>
		<OString a="v"><e path="format.abc.Index"><c path="String"/></e></OString>
		<OSmallInt a="v"><c path="Int"/></OSmallInt>
		<OSetThis/>
		<OSetSuper a="v"><t path="format.abc.IName"/></OSetSuper>
		<OSetSlot a="s"><t path="format.abc.Slot"/></OSetSlot>
		<OSetReg a="r"><t path="format.abc.Register"/></OSetReg>
		<OSetProp a="p"><t path="format.abc.IName"/></OSetProp>
		<OSetGlobalSlot a="s"><t path="format.abc.Slot"/></OSetGlobalSlot>
		<OScope/>
		<ORetVoid/>
		<ORet/>
		<ORegKill a="r"><t path="format.abc.Register"/></ORegKill>
		<OReg a="r"><t path="format.abc.Register"/></OReg>
		<OPushWith/>
		<OPopScope/>
		<OPop/>
		<OOp a="op"><e path="format.abc.Operation"/></OOp>
		<OObject a="nfields"><c path="Int"/></OObject>
		<ONull/>
		<ONop/>
		<ONext a="r1:r2">
			<t path="format.abc.Register"/>
			<t path="format.abc.Register"/>
		</ONext>
		<ONewBlock/>
		<ONamespace a="v"><e path="format.abc.Index"><e path="format.abc.Namespace"/></e></ONamespace>
		<ONaN/>
		<OLabel2 a="name"><c path="String"/></OLabel2>
		<OLabel/>
		<OJump3 a="landingName"><c path="String"/></OJump3>
		<OJump2 a="j:landingName:delta">
			<e path="format.abc.JumpStyle"/>
			<c path="String"/>
			<c path="Int"/>
		</OJump2>
		<OJump a="j:delta">
			<e path="format.abc.JumpStyle"/>
			<c path="Int"/>
		</OJump>
		<OIsType a="t"><t path="format.abc.IName"/></OIsType>
		<OIntRef a="v"><e path="format.abc.Index"><c path="haxe.Int32"/></e></OIntRef>
		<OInt a="v"><c path="Int"/></OInt>
		<OInstanceOf/>
		<OInitProp a="p"><t path="format.abc.IName"/></OInitProp>
		<OIncrReg a="r"><t path="format.abc.Register"/></OIncrReg>
		<OIncrIReg a="r"><t path="format.abc.Register"/></OIncrIReg>
		<OHasNext/>
		<OGetSuper a="v"><t path="format.abc.IName"/></OGetSuper>
		<OGetSlot a="s"><t path="format.abc.Slot"/></OGetSlot>
		<OGetScope a="n"><c path="Int"/></OGetScope>
		<OGetProp a="p"><t path="format.abc.IName"/></OGetProp>
		<OGetLex a="p"><t path="format.abc.IName"/></OGetLex>
		<OGetGlobalSlot a="s"><t path="format.abc.Slot"/></OGetGlobalSlot>
		<OGetGlobalScope/>
		<OGetDescendants a="c"><t path="format.abc.IName"/></OGetDescendants>
		<OFunction a="f"><e path="format.abc.Index"><t path="format.abc.MethodType"/></e></OFunction>
		<OForIn/>
		<OForEach/>
		<OFloat a="v"><e path="format.abc.Index"><c path="Float"/></e></OFloat>
		<OFindPropStrict a="p"><t path="format.abc.IName"/></OFindPropStrict>
		<OFindProp a="p"><t path="format.abc.IName"/></OFindProp>
		<OFindDefinition a="d"><t path="format.abc.IName"/></OFindDefinition>
		<OFalse/>
		<ODxNsLate/>
		<ODxNs a="v"><e path="format.abc.Index"><c path="String"/></e></ODxNs>
		<ODup/>
		<ODeleteProp a="p"><t path="format.abc.IName"/></ODeleteProp>
		<ODecrReg a="r"><t path="format.abc.Register"/></ODecrReg>
		<ODecrIReg a="r"><t path="format.abc.Register"/></ODecrIReg>
		<ODebugReg a="name:r:line">
			<e path="format.abc.Index"><c path="String"/></e>
			<t path="format.abc.Register"/>
			<c path="Int"/>
		</ODebugReg>
		<ODebugLine a="line"><c path="Int"/></ODebugLine>
		<ODebugFile a="file"><e path="format.abc.Index"><c path="String"/></e></ODebugFile>
		<OConstructSuper a="nargs"><c path="Int"/></OConstructSuper>
		<OConstructProperty a="name:nargs">
			<t path="format.abc.IName"/>
			<c path="Int"/>
		</OConstructProperty>
		<OConstruct a="nargs"><c path="Int"/></OConstruct>
		<OClassDef a="c"><e path="format.abc.Index"><t path="format.abc.ClassDef"/></e></OClassDef>
		<OCheckIsXml/>
		<OCatch a="c"><c path="Int"/></OCatch>
		<OCast a="t"><t path="format.abc.IName"/></OCast>
		<OCallSuperVoid a="name:nargs">
			<t path="format.abc.IName"/>
			<c path="Int"/>
		</OCallSuperVoid>
		<OCallSuper a="name:nargs">
			<t path="format.abc.IName"/>
			<c path="Int"/>
		</OCallSuper>
		<OCallStatic a="meth:nargs">
			<e path="format.abc.Index"><t path="format.abc.MethodType"/></e>
			<c path="Int"/>
		</OCallStatic>
		<OCallStack a="nargs"><c path="Int"/></OCallStack>
		<OCallProperty a="name:nargs">
			<t path="format.abc.IName"/>
			<c path="Int"/>
		</OCallProperty>
		<OCallPropVoid a="name:nargs">
			<t path="format.abc.IName"/>
			<c path="Int"/>
		</OCallPropVoid>
		<OCallPropLex a="name:nargs">
			<t path="format.abc.IName"/>
			<c path="Int"/>
		</OCallPropLex>
		<OCallMethod a="slot:nargs">
			<t path="format.abc.Slot"/>
			<c path="Int"/>
		</OCallMethod>
		<OBreakPointLine a="n"><c path="Int"/></OBreakPointLine>
		<OBreakPoint/>
		<OAsType a="t"><t path="format.abc.IName"/></OAsType>
		<OAsString/>
		<OAsObject/>
		<OAsAny/>
		<OArray a="nvalues"><c path="Int"/></OArray>
		<OApplyType a="nargs"><c path="Int"/></OApplyType>
	</enum>
	<enum path="format.abc.JumpStyle" params="" file="src/format/abc/Data.hx" module="format.abc.Data">
		<JTrue/>
		<JPhysNeq/>
		<JPhysEq/>
		<JNotLte/>
		<JNotLt/>
		<JNotGte/>
		<JNotGt/>
		<JNeq/>
		<JLte/>
		<JLt/>
		<JGte/>
		<JGt/>
		<JFalse/>
		<JEq/>
		<JAlways/>
	</enum>
	<enum path="format.abc.Operation" params="" file="src/format/abc/Data.hx" module="format.abc.Data">
		<OpXor/>
		<OpUShr/>
		<OpSub/>
		<OpSign8/>
		<OpSign16/>
		<OpSign1/>
		<OpShr/>
		<OpShl/>
		<OpPhysEq/>
		<OpOr/>
		<OpNot/>
		<OpNeg/>
		<OpMul/>
		<OpMod/>
		<OpMemSetFloat/>
		<OpMemSetDouble/>
		<OpMemSet8/>
		<OpMemSet32/>
		<OpMemSet16/>
		<OpMemGetFloat/>
		<OpMemGetDouble/>
		<OpMemGet8/>
		<OpMemGet32/>
		<OpMemGet16/>
		<OpLte/>
		<OpLt/>
		<OpIs/>
		<OpIncr/>
		<OpIn/>
		<OpISub/>
		<OpINeg/>
		<OpIMul/>
		<OpIIncr/>
		<OpIDecr/>
		<OpIAdd/>
		<OpGte/>
		<OpGt/>
		<OpEq/>
		<OpDiv/>
		<OpDecr/>
		<OpBitNot/>
		<OpAs/>
		<OpAnd/>
		<OpAdd/>
	</enum>
	<class path="format.tools.Inflate" params="" file="src/format/tools/Inflate.hx"><run public="1" set="method" line="31" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></run></class>
	<class path="IntIter" params="" file="C:\Program Files\Motion-Twin\haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="Math" params="" file="C:\Program Files\Motion-Twin\haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<typedef path="format.mp3.MP3" params="" file="src/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<sampleSize><c path="Int"/></sampleSize>
	<sampleCount><c path="Int"/></sampleCount>
	<id3v2><t path="format.mp3.ID3v2Info"/></id3v2>
	<frames><c path="Array"><t path="format.mp3.MP3Frame"/></c></frames>
</a></typedef>
	<typedef path="format.mp3.ID3v2Info" params="" file="src/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<versionBytes><c path="Int"/></versionBytes>
	<flagByte><c path="Int"/></flagByte>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<typedef path="format.mp3.MP3Frame" params="" file="src/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<header><t path="format.mp3.MP3Header"/></header>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<typedef path="format.mp3.MP3Header" params="" file="src/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<version><e path="format.mp3.MPEGVersion"/></version>
	<samplingRate><e path="format.mp3.SamplingRate"/></samplingRate>
	<privateBit><e path="Bool"/></privateBit>
	<layer><e path="format.mp3.Layer"/></layer>
	<isPadded><e path="Bool"/></isPadded>
	<isOriginal><e path="Bool"/></isOriginal>
	<isMSStereo><e path="Bool"/></isMSStereo>
	<isIntensityStereo><e path="Bool"/></isIntensityStereo>
	<isCopyrighted><e path="Bool"/></isCopyrighted>
	<hasCrc><e path="Bool"/></hasCrc>
	<emphasis><e path="format.mp3.Emphasis"/></emphasis>
	<crc16><c path="Int"/></crc16>
	<channelMode><e path="format.mp3.ChannelMode"/></channelMode>
	<bitrate><e path="format.mp3.Bitrate"/></bitrate>
</a></typedef>
	<enum path="format.mp3.MPEGVersion" params="" file="src/format/mp3/Data.hx" module="format.mp3.Data">
		<MPEG_V25/>
		<MPEG_V2/>
		<MPEG_V1/>
		<MPEG_Reserved/>
	</enum>
	<enum path="format.mp3.Layer" params="" file="src/format/mp3/Data.hx" module="format.mp3.Data">
		<LayerReserved/>
		<Layer3/>
		<Layer2/>
		<Layer1/>
	</enum>
	<enum path="format.mp3.ChannelMode" params="" file="src/format/mp3/Data.hx" module="format.mp3.Data">
		<Stereo/>
		<Mono/>
		<JointStereo/>
		<DualChannel/>
	</enum>
	<enum path="format.mp3.Emphasis" params="" file="src/format/mp3/Data.hx" module="format.mp3.Data">
		<NoEmphasis/>
		<Ms50_15/>
		<InvalidEmphasis/>
		<CCIT_J17/>
	</enum>
	<enum path="ValueType" params="" file="C:\Program Files\Motion-Twin\haxe/std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
		<haxe_doc>
	The diffent possible runtime types of a value.
	See [Type] for the haXe Reflection API.
</haxe_doc>
	</enum>
	<class path="Type" params="" file="C:\Program Files\Motion-Twin\haxe/std/Type.hx">
		<getClass public="1" params="T" set="method" line="26" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="89" static="1">
			<f a="o">
				<d/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="129" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="152" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="177" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="194" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="256" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="313" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="365" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="421" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="442" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<describe set="method" line="449" static="1"><f a="t:fact">
	<d/>
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" set="method" line="467" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="516" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="559" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="580" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="703" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="775" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="790" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="810" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/ui/ContextMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<hideBuiltInItems public="1" set="method"><f a=""><e path="Void"/></f></hideBuiltInItems>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="XmlType" params="" file="C:\Program Files\Motion-Twin\haxe/std/Xml.hx" module="Xml"><haxe_doc>
	An abstract type representing the type of the Xml
	Node. You can compare it to [Xml] statics and can
	use [Std.string(t)] to get a string reprensation
	of the type.
</haxe_doc></enum>
	<class path="EReg" params="" file="C:\Program Files\Motion-Twin\haxe/std/EReg.hx">
		<r><d/></r>
		<result><c path="+Array"/></result>
		<match public="1" set="method" line="85">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the regular expression matches the String.
		Updates the internal state accordingly.
	</haxe_doc>
		</match>
		<matched public="1" set="method" line="125">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.
	</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="152">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was as the left of
		of the matched substring.
	</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="178">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was at the right of
		of the matched substring.
	</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="210">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>
		Returns the position of the matched substring within the
		original matched string.
	</haxe_doc>
		</matchedPos>
		<split public="1" set="method" line="230">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split a string by using the regular expression to match
		the separators.
	</haxe_doc>
		</split>
		<replace public="1" set="method" line="273">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.
	</haxe_doc>
		</replace>
		<customReplace public="1" set="method" line="339">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>
		For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.
	</haxe_doc>
		</customReplace>
		<new public="1" set="method" line="52">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new regular expression with pattern [r] and
		options [opt].
	</haxe_doc>
		</new>
		<haxe_doc>
	Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.
</haxe_doc>
	</class>
	<class path="flash.FlashXml__" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/FlashXml__.hx">
		<enode line="30" static="1"><c path="EReg"/></enode>
		<ecdata line="31" static="1"><c path="EReg"/></ecdata>
		<edoctype line="32" static="1"><c path="EReg"/></edoctype>
		<eend line="33" static="1"><c path="EReg"/></eend>
		<epcdata line="34" static="1"><c path="EReg"/></epcdata>
		<ecomment line="35" static="1"><c path="EReg"/></ecomment>
		<eprolog line="36" static="1"><c path="EReg"/></eprolog>
		<eattribute line="38" static="1"><c path="EReg"/></eattribute>
		<eclose line="39" static="1"><c path="EReg"/></eclose>
		<ecdata_end line="40" static="1"><c path="EReg"/></ecdata_end>
		<edoctype_elt line="41" static="1"><c path="EReg"/></edoctype_elt>
		<ecomment_end line="42" static="1"><c path="EReg"/></ecomment_end>
		<Element public="1" static="1"><c path="String"/></Element>
		<PCData public="1" static="1"><c path="String"/></PCData>
		<CData public="1" static="1"><c path="String"/></CData>
		<Comment public="1" static="1"><c path="String"/></Comment>
		<DocType public="1" static="1"><c path="String"/></DocType>
		<Prolog public="1" static="1"><c path="String"/></Prolog>
		<Document public="1" static="1"><c path="String"/></Document>
		<parse public="1" set="method" line="63" static="1"><f a="str">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></parse>
		<createElement public="1" set="method" line="173" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createElement>
		<createPCData public="1" set="method" line="182" static="1"><f a="data">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createPCData>
		<createCData public="1" set="method" line="189" static="1"><f a="data">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createCData>
		<createComment public="1" set="method" line="196" static="1"><f a="data">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createComment>
		<createDocType public="1" set="method" line="203" static="1"><f a="data">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createDocType>
		<createProlog public="1" set="method" line="210" static="1"><f a="data">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createProlog>
		<createDocument public="1" set="method" line="217" static="1"><f a=""><c path="flash.FlashXml__"/></f></createDocument>
		<nodeType public="1" set="null"><e path="XmlType"/></nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName"><c path="String"/></nodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue"><c path="String"/></nodeValue>
		<parent public="1" get="getParent" set="null"><c path="flash.FlashXml__"/></parent>
		<_nodeName><c path="String"/></_nodeName>
		<_nodeValue><c path="String"/></_nodeValue>
		<_attributes><c path="Hash"><c path="String"/></c></_attributes>
		<_children><c path="Array"><c path="flash.FlashXml__"/></c></_children>
		<_parent><c path="flash.FlashXml__"/></_parent>
		<getNodeName set="method" line="224"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName set="method" line="230"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeValue set="method" line="236"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue set="method" line="242"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getParent set="method" line="248"><f a=""><c path="flash.FlashXml__"/></f></getParent>
		<get public="1" set="method" line="252"><f a="att">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<set public="1" set="method" line="258"><f a="att:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></set>
		<remove public="1" set="method" line="264"><f a="att">
	<c path="String"/>
	<e path="Void"/>
</f></remove>
		<exists public="1" set="method" line="270"><f a="att">
	<c path="String"/>
	<e path="Bool"/>
</f></exists>
		<attributes public="1" set="method" line="276"><f a=""><t path="Iterator"><c path="String"/></t></f></attributes>
		<iterator public="1" set="method" line="282"><f a=""><a>
	<next><f a=""><c path="flash.FlashXml__"/></f></next>
	<hasNext><f a=""><e path="Bool"/></f></hasNext>
</a></f></iterator>
		<elements public="1" set="method" line="296"><f a=""><a>
	<next><f a=""><c path="flash.FlashXml__"/></f></next>
	<hasNext><f a=""><e path="Bool"/></f></hasNext>
</a></f></elements>
		<elementsNamed public="1" set="method" line="328"><f a="name">
	<c path="String"/>
	<a>
		<next><f a=""><c path="flash.FlashXml__"/></f></next>
		<hasNext><f a=""><e path="Bool"/></f></hasNext>
	</a>
</f></elementsNamed>
		<firstChild public="1" set="method" line="361"><f a=""><c path="flash.FlashXml__"/></f></firstChild>
		<firstElement public="1" set="method" line="366"><f a=""><c path="flash.FlashXml__"/></f></firstElement>
		<addChild public="1" set="method" line="379"><f a="x">
	<c path="flash.FlashXml__"/>
	<e path="Void"/>
</f></addChild>
		<removeChild public="1" set="method" line="386"><f a="x">
	<c path="flash.FlashXml__"/>
	<e path="Bool"/>
</f></removeChild>
		<insertChild public="1" set="method" line="394"><f a="x:pos">
	<c path="flash.FlashXml__"/>
	<c path="Int"/>
	<e path="Void"/>
</f></insertChild>
		<toString public="1" set="method" line="401"><f a=""><c path="String"/></f></toString>
		<new set="method" line="170"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Xml" params="" file="C:\Program Files\Motion-Twin\haxe/std/Xml.hx" extern="1">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Document>
		<parse public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Parse a String into an Xml object.
	</haxe_doc>
		</parse>
		<createElement public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createCData>
		<createComment public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocType>
		<createProlog public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createProlog>
		<createDocument public="1" set="method" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>
		Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.
	</haxe_doc>
		</nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>
		Returns the node name of an Element.
	</haxe_doc>
		</nodeName>
		<getNodeName set="method"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>
		Returns the node value. Only works if the Xml node is not an Element or a Document.
	</haxe_doc>
		</nodeValue>
		<getNodeValue set="method"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<get public="1" set="method">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.
	</haxe_doc>
		</get>
		<set public="1" set="method">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the given attribute value for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</set>
		<remove public="1" set="method">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Removes an attribute for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</remove>
		<exists public="1" set="method">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the Element node has a given attribute.
		Attributes are case-sensitive.
	</haxe_doc>
		</exists>
		<attributes public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an [Iterator] on all the attributes values.
	</haxe_doc>
		</attributes>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>
		Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.
	</haxe_doc>
		</parent>
		<getParent set="method"><f a=""><c path="Xml"/></f></getParent>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</iterator>
		<elements public="1" set="method">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node.
	</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node which is an Element.
	</haxe_doc>
		</firstElement>
		<addChild public="1" set="method">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.
	</haxe_doc>
		</addChild>
		<removeChild public="1" set="method">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.
	</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts a child at the given position among the other childs.
	</haxe_doc>
		</insertChild>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a String representation of the Xml node.
	</haxe_doc>
		</toString>
		<haxe_doc>
	The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.
</haxe_doc>
	</class>
	<enum path="flash.display.JointStyle" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
	</enum>
	<enum path="flash.events.EventPhase" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
	</enum>
	<enum path="flash.text.TextFormatAlign" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/text/TextFormatAlign.hx">
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<CENTER/>
	</enum>
	<class path="be.haxer.hxswfml.AbcWriter" params="" file="src/be/haxer/hxswfml/AbcWriter.hx">
		<log public="1"><e path="Bool"/></log>
		<strict public="1"><e path="Bool"/></strict>
		<name public="1"><c path="String"/></name>
		<ctx><c path="format.abc.Context"/></ctx>
		<className><c path="String"/></className>
		<functionClosureName><c path="String"/></functionClosureName>
		<curClassName><c path="String"/></curClassName>
		<curClass><t path="format.abc.ClassDef"/></curClass>
		<maxStack><c path="Int"/></maxStack>
		<maxScopeStack><c path="Int"/></maxScopeStack>
		<currentStack><c path="Int"/></currentStack>
		<currentScopeStack><c path="Int"/></currentScopeStack>
		<imports><c path="Hash"><c path="String"/></c></imports>
		<functionClosures><c path="Hash"><e path="format.abc.Index"><t path="format.abc.MethodType"/></e></c></functionClosures>
		<inits><c path="Hash"><e path="format.abc.Index"><t path="format.abc.MethodType"/></e></c></inits>
		<classDefs><c path="Hash"><e path="format.abc.Index"><t path="format.abc.ClassDef"/></e></c></classDefs>
		<jumps><c path="Hash"><f a=""><e path="Void"/></f></c></jumps>
		<labels><c path="Hash"><f a="">
	<e path="format.abc.JumpStyle"/>
	<e path="Void"/>
</f></c></labels>
		<xml2abc public="1" set="method" line="34"><f a="xml">
	<c path="String"/>
	<c path="Array"><e path="format.swf.SWFTag"/></c>
</f></xml2abc>
		<xmlToabc public="1" set="method" line="52"><f a="xml:?info">
	<c path="Xml"/>
	<e path="Bool"/>
	<d/>
</f></xmlToabc>
		<createFunction set="method" line="180"><f a="node:functionType:?isInterface">
	<c path="Xml"/>
	<c path="String"/>
	<e path="Bool"/>
	<t path="format.abc.Function"/>
</f></createFunction>
		<writeCodeBlock set="method" line="305"><f a="member:f">
	<c path="Xml"/>
	<a><trys><a>
	<push><f a="">
	<a>
		<variable><t path="format.abc.IName"/></variable>
		<type><t path="format.abc.IName"/></type>
		<start><t path="Null"><c path="Int"/></t></start>
		<handle><t path="Null"><c path="Int"/></t></handle>
		<end><t path="Null"><c path="Int"/></t></end>
	</a>
	<c path="Int"/>
</f></push>
	<length><c path="Int"/></length>
</a></trys></a>
	<e path="Void"/>
</f></writeCodeBlock>
		<abc2xml public="1" set="method" line="473"><f a="abc">
	<unknown/>
	<c path="String"/>
</f></abc2xml>
		<getImport set="method" line="477"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getImport>
		<namespaceType set="method" line="484"><f a="ns">
	<c path="String"/>
	<e path="format.abc.Index"><e path="format.abc.Namespace"/></e>
</f></namespaceType>
		<parseLocals set="method" line="500"><f a="locals">
	<c path="String"/>
	<t path="Null"><c path="Array"><t path="format.abc.Field"/></c></t>
</f></parseLocals>
		<parseFieldKind set="method" line="520"><f a="fld">
	<c path="String"/>
	<e path="format.abc.FieldKind"/>
</f></parseFieldKind>
		<nonEmptyStack set="method" line="537"><f a="fname">
	<c path="String"/>
	<e path="Void"/>
</f></nonEmptyStack>
		<stackError set="method" line="545"><f a="op:type">
	<e path="format.abc.OpCode"/>
	<c path="Int"/>
	<e path="Void"/>
</f></stackError>
		<scopeStackError set="method" line="554"><f a="op:type">
	<e path="format.abc.OpCode"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scopeStackError>
		<urlDecode set="method" line="564"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></urlDecode>
		<updateStacks set="method" line="568"><f a="opc">
	<e path="format.abc.OpCode"/>
	<e path="Void"/>
</f></updateStacks>
		<logStack set="method" line="1217"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></logStack>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * ...
 * @author Jan J. Flanders
 </haxe_doc>
	</class>
	<enum path="flash.display.InterpolationMethod" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
	</enum>
	<enum path="format.zip.ExtraField" params="" file="src/format/zip/Data.hx" module="format.zip.Data">
		<FUnknown a="tag:bytes">
			<c path="Int"/>
			<c path="haxe.io.Bytes"/>
		</FUnknown>
		<FInfoZipUnicodePath a="name:crc">
			<c path="String"/>
			<c path="haxe.Int32"/>
		</FInfoZipUnicodePath>
	</enum>
	<typedef path="format.zip.Entry" params="" file="src/format/zip/Data.hx" module="format.zip.Data"><a>
	<fileTime><c path="Date"/></fileTime>
	<fileSize><c path="Int"/></fileSize>
	<fileName><c path="String"/></fileName>
	<extraFields><t path="Null"><c path="List"><d/></c></t></extraFields>
	<dataSize><c path="Int"/></dataSize>
	<data><t path="Null"><c path="haxe.io.Bytes"/></t></data>
	<crc32><t path="Null"><d/></t></crc32>
	<compressed><e path="Bool"/></compressed>
</a></typedef>
	<typedef path="format.zip.Data" params="" file="src/format/zip/Data.hx"><c path="List"><t path="format.zip.Entry"/></c></typedef>
	<class path="flash.utils.IDataOutput" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/utils/IDataOutput.hx" extern="1" interface="1">
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
	</class>
	<class path="StringBuf" params="" file="C:\Program Files\Motion-Twin\haxe/std/StringBuf.hx">
		<add public="1" get="inline" set="null" line="54">
			<f a="?x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="69">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="87">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="103">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="flash.utils.ByteArray"/></b>
		<new public="1" set="method" line="39">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<enum path="flash.display.CapsStyle" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
	</enum>
	<class path="flash.display.MovieClip" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<enabled public="1"><e path="Bool"/></enabled>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></addFrameScript>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<nextScene public="1" set="method"><f a=""><e path="Void"/></f></nextScene>
		<play public="1" set="method"><f a=""><e path="Void"/></f></play>
		<prevFrame public="1" set="method"><f a=""><e path="Void"/></f></prevFrame>
		<prevScene public="1" set="method"><f a=""><e path="Void"/></f></prevScene>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="format.abc.Writer" params="" file="src/format/abc/Writer.hx">
		<write public="1" set="method" line="338" static="1"><f a="out:data">
	<c path="haxe.io.Output"/>
	<c path="format.abc.ABCData"/>
	<e path="Void"/>
</f></write>
		<o><c path="haxe.io.Output"/></o>
		<opw><c path="format.abc.OpWriter"/></opw>
		<beginTag set="method" line="41"><f a="id:len">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></beginTag>
		<writeInt get="inline" set="null" line="49"><f a="n">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeUInt get="inline" set="null" line="53"><f a="n">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt>
		<writeList params="T" set="method" line="57"><f a="a:write">
	<c path="Array"><c path="writeList.T"/></c>
	<f a="">
		<c path="writeList.T"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></writeList>
		<writeList2 params="T" set="method" line="67"><f a="a:write">
	<c path="Array"><c path="writeList2.T"/></c>
	<f a="">
		<c path="writeList2.T"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></writeList2>
		<writeString set="method" line="73"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<writeIndex set="method" line="78"><f a="i">
	<e path="format.abc.Index"><d/></e>
	<e path="Void"/>
</f></writeIndex>
		<writeIndexOpt set="method" line="84"><f a="i">
	<e path="format.abc.Index"><d/></e>
	<e path="Void"/>
</f></writeIndexOpt>
		<writeNamespace set="method" line="92"><f a="n">
	<e path="format.abc.Namespace"/>
	<e path="Void"/>
</f></writeNamespace>
		<writeNsSet set="method" line="118"><f a="n">
	<t path="format.abc.NamespaceSet"/>
	<e path="Void"/>
</f></writeNsSet>
		<writeNameByte get="inline" set="null" line="124"><f a="k:n">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeNameByte>
		<writeName set="method" line="128"><f a="?k:n">
	<c path="Int"/>
	<e path="format.abc.Name"/>
	<e path="Void"/>
</f></writeName>
		<writeValue set="method" line="164"><f a="extra:v">
	<e path="Bool"/>
	<e path="format.abc.Value"/>
	<e path="Void"/>
</f></writeValue>
		<writeField set="method" line="196"><f a="f">
	<t path="format.abc.Field"/>
	<e path="Void"/>
</f></writeField>
		<writeMethodType set="method" line="233"><f a="m">
	<t path="format.abc.MethodType"/>
	<e path="Void"/>
</f></writeMethodType>
		<writeMetadata set="method" line="268"><f a="m">
	<t path="format.abc.Metadata"/>
	<e path="Void"/>
</f></writeMetadata>
		<writeClass set="method" line="277"><f a="c">
	<t path="format.abc.ClassDef"/>
	<e path="Void"/>
</f></writeClass>
		<writeInit set="method" line="293"><f a="i">
	<t path="format.abc.Init"/>
	<e path="Void"/>
</f></writeInit>
		<writeTryCatch set="method" line="298"><f a="t">
	<t path="format.abc.TryCatch"/>
	<e path="Void"/>
</f></writeTryCatch>
		<writeFunction set="method" line="306"><f a="f">
	<t path="format.abc.Function"/>
	<e path="Void"/>
</f></writeFunction>
		<writeABC set="method" line="318"><f a="d">
	<c path="format.abc.ABCData"/>
	<e path="Void"/>
</f></writeABC>
		<new public="1" set="method" line="36"><f a="o">
	<c path="haxe.io.Output"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="format.tools.IO" params="" file="src/format/tools/IO.hx"><copy public="1" set="method" line="31" static="1"><f a="i:o:buf:size">
	<c path="haxe.io.Input"/>
	<c path="haxe.io.Output"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<e path="Void"/>
</f></copy></class>
	<class path="flash.text.StyleSheet" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<d/>
</f></getStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<e path="Void"/>
</f></parseCSS>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyle>
		<transform public="1" set="method"><f a="formatObject">
	<d/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.geom.Point" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<length public="1" set="null"><c path="Float"/></length>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<normalize public="1" set="method"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.utils.Dictionary" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/utils/Dictionary.hx" extern="1"><new public="1" set="method"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new></class>
	<class path="Enum" params="T" file="C:\Program Files\Motion-Twin\haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="flash.display.Scene" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/Scene.hx" extern="1">
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<name public="1" set="null"><c path="String"/></name>
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Output" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/Output.hx">
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<writeByte public="1" set="method" line="37"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="41"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="64"><f a=""><e path="Void"/></f></flush>
		<close public="1" set="method" line="67"><f a=""><e path="Void"/></f></close>
		<setEndian set="method" line="70"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<write public="1" set="method" line="77"><f a="s">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></write>
		<writeFullBytes public="1" set="method" line="88"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeFullBytes>
		<writeFloat public="1" set="method" line="96"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method" line="108"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeInt8 public="1" set="method" line="120"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeInt16 public="1" set="method" line="126"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeUInt16 public="1" set="method" line="131"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt24 public="1" set="method" line="142"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt24>
		<writeUInt24 public="1" set="method" line="147"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt24>
		<writeInt31 public="1" set="method" line="160"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt30 public="1" set="method" line="177"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt32 public="1" set="method" line="192"><f a="x">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<prepare public="1" set="method" line="212">
			<f a="nbytes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.
	</haxe_doc>
		</prepare>
		<writeInput public="1" set="method" line="215"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeInput>
		<writeString public="1" set="method" line="237"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<haxe_doc>
	An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.
</haxe_doc>
	</class>
	<class path="be.haxer.hxswfml.AbcReader" params="" file="src/be/haxer/hxswfml/AbcReader.hx">
		<abcFile><c path="format.abc.ABCData"/></abcFile>
		<indentLevel><c path="Int"/></indentLevel>
		<functionClosures><c path="Array"><c path="String"/></c></functionClosures>
		<functionClosuresBodies><c path="Array"><d/></c></functionClosuresBodies>
		<functionParseIndex><c path="Int"/></functionParseIndex>
		<currentFunctionName><c path="String"/></currentFunctionName>
		<className><c path="String"/></className>
		<debugLines><c path="Array"><c path="String"/></c></debugLines>
		<debugFile><c path="String"/></debugFile>
		<debugFileName><c path="String"/></debugFileName>
		<lastJump><c path="String"/></lastJump>
		<lastLabel><c path="String"/></lastLabel>
		<abcReader_import><c path="be.haxer.hxswfml.AbcReader"/></abcReader_import>
		<abcId><c path="Int"/></abcId>
		<debugInfo public="1"><e path="Bool"/></debugInfo>
		<jumpInfo public="1"><e path="Bool"/></jumpInfo>
		<sourceInfo public="1"><e path="Bool"/></sourceInfo>
		<abc2xml public="1" set="method" line="58"><f a="fileName:?_swf">
	<c path="String"/>
	<t path="haxe.io.BytesData"/>
	<c path="String"/>
</f></abc2xml>
		<getBytes set="method" line="119"><f a="fileName:?swf">
	<c path="String"/>
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<abcToXml set="method" line="127"><f a="data:infos">
	<c path="haxe.io.Bytes"/>
	<a><label><c path="String"/></label></a>
	<c path="String"/>
</f></abcToXml>
		<decodeToXML set="method" line="547"><f a="ops:f">
	<c path="Array"><e path="format.abc.OpCode"/></c>
	<a><trys><c path="Array"><t path="format.abc.TryCatch"/></c></trys></a>
	<c path="String"/>
</f></decodeToXML>
		<createFunctionClosure set="method" line="830"><f a="f">
	<e path="format.abc.Index"><t path="format.abc.MethodType"/></e>
	<c path="String"/>
</f></createFunctionClosure>
		<parseMethodExtra get="inline" set="null" line="882"><f a="extra">
	<t path="format.abc.MethodTypeExtra"/>
	<c path="String"/>
</f></parseMethodExtra>
		<parseLocals get="inline" set="null" line="917"><f a="locals">
	<c path="Array"><t path="format.abc.Field"/></c>
	<c path="String"/>
</f></parseLocals>
		<indent get="inline" set="null" line="951"><f a=""><c path="String"/></f></indent>
		<getString get="inline" set="null" line="960"><f a="id">
	<e path="format.abc.Index"><c path="String"/></e>
	<c path="String"/>
</f></getString>
		<getInt get="inline" set="null" line="964"><f a="id">
	<e path="format.abc.Index"><c path="haxe.Int32"/></e>
	<c path="String"/>
</f></getInt>
		<getUInt get="inline" set="null" line="968"><f a="id">
	<e path="format.abc.Index"><c path="haxe.Int32"/></e>
	<c path="String"/>
</f></getUInt>
		<getFloat get="inline" set="null" line="972"><f a="id">
	<e path="format.abc.Index"><c path="Float"/></e>
	<c path="String"/>
</f></getFloat>
		<getMethod get="inline" set="null" line="976"><f a="id">
	<e path="format.abc.Index"><t path="format.abc.MethodType"/></e>
	<t path="format.abc.MethodType"/>
</f></getMethod>
		<getClass get="inline" set="null" line="980"><f a="id">
	<e path="format.abc.Index"><t path="format.abc.ClassDef"/></e>
	<t path="format.abc.ClassDef"/>
</f></getClass>
		<getNamespace get="inline" set="null" line="984"><f a="id">
	<e path="format.abc.Index"><e path="format.abc.Namespace"/></e>
	<c path="String"/>
</f></getNamespace>
		<getName set="method" line="999"><f a="id">
	<t path="format.abc.IName"/>
	<c path="String"/>
</f></getName>
		<getNameType set="method" line="1011"><f a="name">
	<e path="format.abc.Name"/>
	<c path="String"/>
</f></getNameType>
		<getFieldName get="inline" set="null" line="1044"><f a="id">
	<t path="format.abc.IName"/>
	<c path="String"/>
</f></getFieldName>
		<cutComma get="inline" set="null" line="1048"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></cutComma>
		<getValue set="method" line="1055"><f a="value">
	<t path="Null"><e path="format.abc.Value"/></t>
	<c path="String"/>
</f></getValue>
		<fileToLines get="inline" set="null" line="1073"><f a="fileName">
	<c path="String"/>
	<c path="String"/>
</f></fileToLines>
		<urlEncode get="inline" set="null" line="1101"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></urlEncode>
		<lineSplitter get="inline" set="null" line="1105"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></lineSplitter>
		<new public="1" set="method" line="44"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * ...
 * @author Jan J. Flanders
 </haxe_doc>
	</class>
	<class path="format.mp3.Writer" params="" file="src/format/mp3/Writer.hx">
		<WRITE_ID3V2 public="1" get="inline" set="null" line="37" static="1"><e path="Bool"/></WRITE_ID3V2>
		<DONT_WRITE_ID3V2 public="1" get="inline" set="null" line="38" static="1"><e path="Bool"/></DONT_WRITE_ID3V2>
		<o><c path="haxe.io.Output"/></o>
		<bits><c path="format.tools.BitsOutput"/></bits>
		<write public="1" set="method" line="53">
			<f a="mp3:?writeId3v2">
				<t path="format.mp3.MP3"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
    * Pass DONT_WRITE_ID3V2 (false) as second parameter to
    * write the mpeg stream without id3v2
    </haxe_doc>
		</write>
		<writeID3v2 public="1" set="method" line="61"><f a="id3v2">
	<t path="format.mp3.ID3v2Info"/>
	<e path="Void"/>
</f></writeID3v2>
		<writeFrame public="1" set="method" line="81"><f a="f">
	<t path="format.mp3.MP3Frame"/>
	<e path="Void"/>
</f></writeFrame>
		<new public="1" set="method" line="43"><f a="output">
	<c path="haxe.io.Output"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/system/ApplicationDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasDefinition>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="format.tools.CRC32" params="" file="src/format/tools/CRC32.hx">
		<POLYNOM get="inline" set="null" line="32" static="1"><c path="haxe.Int32"/></POLYNOM>
		<encode public="1" set="method" line="74" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.Int32"/>
</f></encode>
		<crc><c path="haxe.Int32"/></crc>
		<run public="1" set="method" line="38"><f a="b">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></run>
		<byte public="1" set="method" line="54"><f a="b">
	<c path="Int"/>
	<e path="Void"/>
</f></byte>
		<get public="1" set="method" line="65"><f a=""><c path="haxe.Int32"/></f></get>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="format.tools.Deflate" params="" file="src/format/tools/Deflate.hx"><run public="1" set="method" line="31" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></run></class>
	<enum path="flash.text.TextFormatDisplay" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
	</enum>
	<typedef path="haxe.io.BytesData" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/BytesData.hx"><c path="flash.utils.ByteArray"/></typedef>
	<enum path="flash.text.GridFitType" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
	</enum>
	<class path="flash.geom.Transform" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/geom/Transform.hx" extern="1">
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="format.abc._Context.NullOutput" params="" file="src/format/abc/Context.hx" private="1" module="format.abc.Context">
		<extends path="haxe.io.Output"/>
		<n public="1"><c path="Int"/></n>
		<writeByte public="1" set="method" line="40" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="44" override="1"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<new public="1" set="method" line="36"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="format.abc.Context" params="" file="src/format/abc/Context.hx">
		<data><c path="format.abc.ABCData"/></data>
		<hstrings><c path="Hash"><c path="Int"/></c></hstrings>
		<curClass><t path="format.abc.ClassDef"/></curClass>
		<curFunction public="1"><a>
	<ops><c path="Array"><e path="format.abc.OpCode"/></c></ops>
	<f><t path="format.abc.Function"/></f>
</a></curFunction>
		<classes><c path="Array"><t path="format.abc.Field"/></c></classes>
		<init><a>
	<ops><c path="Array"><e path="format.abc.OpCode"/></c></ops>
	<f><t path="format.abc.Function"/></f>
</a></init>
		<fieldSlot><c path="Int"/></fieldSlot>
		<registers><c path="Array"><e path="Bool"/></c></registers>
		<bytepos><c path="format.abc._Context.NullOutput"/></bytepos>
		<opw><c path="format.abc.OpWriter"/></opw>
		<classSupers><c path="List"><e path="format.abc.Index"><e path="format.abc.Name"/></e></c></classSupers>
		<emptyString public="1" set="null"><e path="format.abc.Index"><c path="String"/></e></emptyString>
		<nsPublic public="1" set="null"><e path="format.abc.Index"><e path="format.abc.Namespace"/></e></nsPublic>
		<arrayProp public="1" set="null"><e path="format.abc.Index"><e path="format.abc.Name"/></e></arrayProp>
		<int public="1" set="method" line="100"><f a="n">
	<c path="haxe.Int32"/>
	<e path="format.abc.Index"><c path="haxe.Int32"/></e>
</f></int>
		<uint public="1" set="method" line="112"><f a="i">
	<c path="haxe.Int32"/>
	<e path="format.abc.Index"><c path="haxe.Int32"/></e>
</f></uint>
		<float public="1" set="method" line="116"><f a="f">
	<c path="Float"/>
	<e path="format.abc.Index"><c path="Float"/></e>
</f></float>
		<string public="1" set="method" line="120"><f a="s">
	<c path="String"/>
	<e path="format.abc.Index"><c path="String"/></e>
</f></string>
		<_namespace public="1" set="method" line="130"><f a="n">
	<e path="format.abc.Namespace"/>
	<e path="format.abc.Index"><e path="format.abc.Namespace"/></e>
</f></_namespace>
		<nsset public="1" set="method" line="135"><f a="ns">
	<t path="format.abc.NamespaceSet"/>
	<e path="format.abc.Index"><t path="format.abc.NamespaceSet"/></e>
</f></nsset>
		<name public="1" set="method" line="153"><f a="n">
	<e path="format.abc.Name"/>
	<e path="format.abc.Index"><e path="format.abc.Name"/></e>
</f></name>
		<getClass public="1" set="method" line="157"><f a="n">
	<t path="format.abc.ClassDef"/>
	<e path="format.abc.Index"><t path="format.abc.ClassDef"/></e>
</f></getClass>
		<type public="1" set="method" line="165"><f a="path">
	<c path="String"/>
	<t path="format.abc.IName"/>
</f></type>
		<typeParams public="1" set="method" line="179"><f a="path">
	<c path="String"/>
	<e path="format.abc.Index"><e path="format.abc.Name"/></e>
</f></typeParams>
		<property public="1" set="method" line="196"><f a="pname:?ns">
	<c path="String"/>
	<e path="format.abc.Index"><e path="format.abc.Namespace"/></e>
	<t path="format.abc.IName"/>
</f></property>
		<methodType public="1" set="method" line="212"><f a="m">
	<t path="format.abc.MethodType"/>
	<e path="format.abc.Index"><t path="format.abc.MethodType"/></e>
</f></methodType>
		<lookup params="T" set="method" line="217"><f a="arr:n">
	<c path="Array"><c path="lookup.T"/></c>
	<c path="lookup.T"/>
	<e path="format.abc.Index"><c path="lookup.T"/></e>
</f></lookup>
		<elookup params="T" set="method" line="249"><f a="arr:n">
	<c path="Array"><c path="elookup.T"/></c>
	<c path="elookup.T"/>
	<e path="format.abc.Index"><c path="elookup.T"/></e>
</f></elookup>
		<getData public="1" set="method" line="257"><f a=""><c path="format.abc.ABCData"/></f></getData>
		<beginInterfaceFunction public="1" set="method" line="260"><f a="args:ret:?extra">
	<c path="Array"><t path="Null"><t path="format.abc.IName"/></t></c>
	<t path="Null"><t path="format.abc.IName"/></t>
	<t path="format.abc.MethodTypeExtra"/>
	<e path="format.abc.Index"><unknown/></e>
</f></beginInterfaceFunction>
		<beginFunction public="1" set="method" line="275"><f a="args:ret:?extra">
	<c path="Array"><t path="Null"><t path="format.abc.IName"/></t></c>
	<t path="Null"><t path="format.abc.IName"/></t>
	<t path="format.abc.MethodTypeExtra"/>
	<e path="format.abc.Index"><t path="format.abc.Function"/></e>
</f></beginFunction>
		<endFunction public="1" set="method" line="295"><f a=""><e path="Void"/></f></endFunction>
		<allocRegister public="1" set="method" line="308"><f a=""><c path="Int"/></f></allocRegister>
		<freeRegister public="1" set="method" line="319"><f a="i">
	<c path="Int"/>
	<e path="Void"/>
</f></freeRegister>
		<beginClass public="1" set="method" line="323"><f a="path:?isInterface">
	<c path="String"/>
	<e path="Bool"/>
	<t path="format.abc.ClassDef"/>
</f></beginClass>
		<endClass public="1" set="method" line="384"><f a="?makeInit">
	<e path="Bool"/>
	<e path="Void"/>
</f></endClass>
		<addClassSuper public="1" set="method" line="439"><f a="sup">
	<c path="String"/>
	<e path="Void"/>
</f></addClassSuper>
		<beginInterfaceMethod public="1" set="method" line="444"><f a="mname:targs:tret:?isStatic:?isOverride:?isFinal:?willAddLater:?kind:?extra:?ns">
	<c path="String"/>
	<c path="Array"><t path="Null"><t path="format.abc.IName"/></t></c>
	<t path="Null"><t path="format.abc.IName"/></t>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="format.abc.MethodKind"/>
	<t path="format.abc.MethodTypeExtra"/>
	<e path="format.abc.Index"><e path="format.abc.Namespace"/></e>
	<t path="format.abc.Function"/>
</f></beginInterfaceMethod>
		<beginMethod public="1" set="method" line="460"><f a="mname:targs:tret:?isStatic:?isOverride:?isFinal:?willAddLater:?kind:?extra:?ns">
	<c path="String"/>
	<c path="Array"><t path="Null"><t path="format.abc.IName"/></t></c>
	<t path="Null"><t path="format.abc.IName"/></t>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="format.abc.MethodKind"/>
	<t path="format.abc.MethodTypeExtra"/>
	<e path="format.abc.Index"><e path="format.abc.Namespace"/></e>
	<t path="format.abc.Function"/>
</f></beginMethod>
		<endMethod public="1" set="method" line="476"><f a=""><e path="Void"/></f></endMethod>
		<defineField public="1" set="method" line="480"><f a="fname:t:?isStatic:?value:?_const:?ns">
	<c path="String"/>
	<t path="Null"><t path="format.abc.IName"/></t>
	<e path="Bool"/>
	<e path="format.abc.Value"/>
	<e path="Bool"/>
	<e path="format.abc.Index"><e path="format.abc.Namespace"/></e>
	<t path="format.abc.Slot"/>
</f></defineField>
		<op public="1" set="method" line="499"><f a="o">
	<e path="format.abc.OpCode"/>
	<e path="Void"/>
</f></op>
		<ops public="1" set="method" line="504"><f a="ops">
	<c path="Array"><e path="format.abc.OpCode"/></c>
	<e path="Void"/>
</f></ops>
		<backwardJump public="1" set="method" line="509"><f a=""><f a="jcond">
	<e path="format.abc.JumpStyle"/>
	<e path="Void"/>
</f></f></backwardJump>
		<jump public="1" set="method" line="518"><f a="jcond">
	<e path="format.abc.JumpStyle"/>
	<f a=""><e path="Void"/></f>
</f></jump>
		<finalize public="1" set="method" line="529"><f a=""><e path="Void"/></f></finalize>
		<new public="1" set="method" line="70"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.Log" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="43" static="1"><f a=""><e path="Void"/></f></clear>
		<setColor public="1" set="dynamic" line="52" static="1"><f a="rgb">
	<c path="Int"/>
	<e path="Void"/>
</f></setColor>
	</class>
	<class path="format.abc.OpWriter" params="" file="src/format/abc/OpWriter.hx">
		<o public="1"><c path="haxe.io.Output"/></o>
		<writeInt public="1" set="method" line="39"><f a="n">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeInt32 public="1" set="method" line="64"><f a="n">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<int set="method" line="90"><f a="i">
	<c path="Int"/>
	<e path="Void"/>
</f></int>
		<b get="inline" set="null" line="94"><f a="v">
	<c path="Int"/>
	<e path="Void"/>
</f></b>
		<reg set="method" line="98"><f a="v">
	<c path="Int"/>
	<e path="Void"/>
</f></reg>
		<idx set="method" line="102"><f a="i">
	<e path="format.abc.Index"><d/></e>
	<e path="Void"/>
</f></idx>
		<jumpCode set="method" line="108"><f a="j">
	<e path="format.abc.JumpStyle"/>
	<c path="Int"/>
</f></jumpCode>
		<operationCode set="method" line="128"><f a="o">
	<e path="format.abc.Operation"/>
	<c path="Int"/>
</f></operationCode>
		<write public="1" set="method" line="177"><f a="op">
	<e path="format.abc.OpCode"/>
	<e path="Void"/>
</f></write>
		<new public="1" set="method" line="35"><f a="o">
	<c path="haxe.io.Output"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="format.swf.Reader" params="" file="src/format/swf/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<bits><c path="format.tools.BitsInput"/></bits>
		<version><c path="Int"/></version>
		<bitsRead><c path="Int"/></bitsRead>
		<readFixed8 get="inline" set="null" line="47"><f a="?i">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
</f></readFixed8>
		<readFixed get="inline" set="null" line="52"><f a=""><c path="haxe.Int32"/></f></readFixed>
		<readUTF8Bytes set="method" line="56"><f a=""><c path="haxe.io.Bytes"/></f></readUTF8Bytes>
		<readRect set="method" line="66"><f a=""><a>
	<top><c path="Int"/></top>
	<right><c path="Int"/></right>
	<left><c path="Int"/></left>
	<bottom><c path="Int"/></bottom>
</a></f></readRect>
		<readMatrixPart set="method" line="81"><f a=""><t path="format.swf.MatrixPart"/></f></readMatrixPart>
		<readMatrix set="method" line="90"><f a=""><t path="format.swf.Matrix"/></f></readMatrix>
		<readRGBA set="method" line="131"><f a="?i">
	<c path="haxe.io.Input"/>
	<t path="format.swf.RGBA"/>
</f></readRGBA>
		<readRGB set="method" line="141"><f a="?i">
	<c path="haxe.io.Input"/>
	<t path="format.swf.RGB"/>
</f></readRGB>
		<readCXAColor set="method" line="150"><f a="nbits">
	<c path="Int"/>
	<t path="format.swf.RGBA"/>
</f></readCXAColor>
		<readCXA set="method" line="159"><f a=""><t path="format.swf.CXA"/></f></readCXA>
		<readGradient set="method" line="171"><f a="ver">
	<c path="Int"/>
	<t path="format.swf.Gradient"/>
</f></readGradient>
		<getLineCap set="method" line="205"><f a="t">
	<c path="Int"/>
	<e path="format.swf.LineCapStyle"/>
</f></getLineCap>
		<readLineStyles set="method" line="214"><f a="ver">
	<c path="Int"/>
	<c path="Array"><t path="format.swf.LineStyle"/></c>
</f></readLineStyles>
		<readFillStyle set="method" line="281"><f a="ver">
	<c path="Int"/>
	<e path="format.swf.FillStyle"/>
</f></readFillStyle>
		<readFillStyles set="method" line="323"><f a="ver">
	<c path="Int"/>
	<c path="Array"><e path="format.swf.FillStyle"/></c>
</f></readFillStyles>
		<readShapeWithStyle set="method" line="337"><f a="ver">
	<c path="Int"/>
	<t path="format.swf.ShapeWithStyleData"/>
</f></readShapeWithStyle>
		<readShapeWithoutStyle set="method" line="347"><f a="ver">
	<c path="Int"/>
	<t path="format.swf.ShapeWithoutStyleData"/>
</f></readShapeWithoutStyle>
		<readShapeRecords set="method" line="357"><f a="ver">
	<c path="Int"/>
	<c path="Array"><e path="format.swf.ShapeRecord"/></c>
</f></readShapeRecords>
		<readClipEvents set="method" line="454"><f a=""><c path="Array"><t path="format.swf.ClipEvent"/></c></f></readClipEvents>
		<readFilterFlags set="method" line="467"><f a="top">
	<e path="Bool"/>
	<a>
		<passes><c path="Int"/></passes>
		<ontop><e path="Bool"/></ontop>
		<knockout><e path="Bool"/></knockout>
		<inner><e path="Bool"/></inner>
	</a>
</f></readFilterFlags>
		<readFilterGradient set="method" line="478"><f a=""><t path="format.swf.GradientFilterData"/></f></readFilterGradient>
		<readFilter set="method" line="501"><f a=""><e path="format.swf.Filter"/></f></readFilter>
		<readFilters set="method" line="555"><f a=""><c path="Array"><e path="format.swf.Filter"/></c></f></readFilters>
		<readShape set="method" line="562"><f a="len:ver">
	<c path="Int"/>
	<c path="Int"/>
	<e path="format.swf.SWFTag"/>
</f></readShape>
		<readMorphGradient set="method" line="595"><f a="ver">
	<c path="Int"/>
	<a>
		<startRatio><c path="Int"/></startRatio>
		<startColor><t path="format.swf.RGBA"/></startColor>
		<endRatio><c path="Int"/></endRatio>
		<endColor><t path="format.swf.RGBA"/></endColor>
	</a>
</f></readMorphGradient>
		<readMorphGradients set="method" line="609"><f a="ver">
	<c path="Int"/>
	<c path="Array"><t path="format.swf.MorphGradient"/></c>
</f></readMorphGradients>
		<readMorphFillStyle set="method" line="622"><f a="ver">
	<c path="Int"/>
	<e path="format.swf.MorphFillStyle"/>
</f></readMorphFillStyle>
		<readMorphFillStyles set="method" line="663"><f a="ver">
	<c path="Int"/>
	<c path="Array"><e path="format.swf.MorphFillStyle"/></c>
</f></readMorphFillStyles>
		<readMorph1LineStyle set="method" line="676"><f a=""><a>
	<startWidth><c path="Int"/></startWidth>
	<startColor><t path="format.swf.RGBA"/></startColor>
	<endWidth><c path="Int"/></endWidth>
	<endColor><t path="format.swf.RGBA"/></endColor>
</a></f></readMorph1LineStyle>
		<readMorph2LineStyle set="method" line="690"><f a=""><e path="format.swf.Morph2LineStyle"/></f></readMorph2LineStyle>
		<readMorph1LineStyles set="method" line="737"><f a=""><c path="Array"><t path="format.swf.Morph1LineStyle"/></c></f></readMorph1LineStyles>
		<readMorph2LineStyles set="method" line="751"><f a=""><c path="Array"><e path="format.swf.Morph2LineStyle"/></c></f></readMorph2LineStyles>
		<readMorphShape set="method" line="765"><f a="ver">
	<c path="Int"/>
	<e path="format.swf.SWFTag"/>
</f></readMorphShape>
		<readBlendMode set="method" line="820"><f a=""><e path="format.swf.BlendMode"/></f></readBlendMode>
		<readPlaceObject set="method" line="840"><f a="v3">
	<e path="Bool"/>
	<c path="format.swf.PlaceObject"/>
</f></readPlaceObject>
		<readLossless set="method" line="860"><f a="len:v2">
	<c path="Int"/>
	<e path="Bool"/>
	<a>
		<width><c path="Int"/></width>
		<height><c path="Int"/></height>
		<data><c path="haxe.io.Bytes"/></data>
		<color><e path="format.swf.ColorModel"/></color>
		<cid><c path="Int"/></cid>
	</a>
</f></readLossless>
		<readSymbols set="method" line="877"><f a=""><c path="Array"><t path="format.swf.SymData"/></c></f></readSymbols>
		<readSound set="method" line="888"><f a="len">
	<c path="Int"/>
	<e path="format.swf.SWFTag"/>
</f></readSound>
		<readLanguage set="method" line="932"><f a=""><e path="format.swf.LangCode"/></f></readLanguage>
		<readGlyphs set="method" line="944"><f a="len:offsets">
	<c path="Int"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><t path="format.swf.ShapeWithoutStyleData"/></c>
</f></readGlyphs>
		<readKerningRecord set="method" line="966"><f a="hasWideCodes">
	<e path="Bool"/>
	<a>
		<charCode2><c path="Int"/></charCode2>
		<charCode1><c path="Int"/></charCode1>
		<adjust><c path="Int"/></adjust>
	</a>
</f></readKerningRecord>
		<readFont1Data set="method" line="974"><f a="len">
	<c path="Int"/>
	<e path="format.swf.FontData"/>
</f></readFont1Data>
		<readFont2Data set="method" line="989"><f a="ver">
	<c path="Int"/>
	<e path="format.swf.FontData"/>
</f></readFont2Data>
		<readFont set="method" line="1096"><f a="len:ver">
	<c path="Int"/>
	<c path="Int"/>
	<e path="format.swf.SWFTag"/>
</f></readFont>
		<readFontInfo set="method" line="1111"><f a="len:ver">
	<c path="Int"/>
	<c path="Int"/>
	<e path="format.swf.SWFTag"/>
</f></readFontInfo>
		<readSoundInfo set="method" line="1151"><f a=""><a>
	<syncStop><e path="Bool"/></syncStop>
	<loopCount><d/></loopCount>
	<hasLoops><e path="Bool"/></hasLoops>
</a></f></readSoundInfo>
		<readEnvelopeRecords set="method" line="1179"><f a="count">
	<c path="Int"/>
	<c path="Array"><t path="format.swf.SoundEnvelope"/></c>
</f></readEnvelopeRecords>
		<readFileAttributes set="method" line="1188"><f a=""><t path="format.swf.FileAttributes"/></f></readFileAttributes>
		<error set="method" line="1202"><f a="?msg">
	<c path="String"/>
	<c path="String"/>
</f></error>
		<readHeader public="1" set="method" line="1206"><f a=""><t path="format.swf.SWFHeader"/></f></readHeader>
		<readTagList public="1" set="method" line="1239"><f a=""><c path="Array"><e path="format.swf.SWFTag"/></c></f></readTagList>
		<readTag public="1" set="method" line="1249"><f a=""><e path="format.swf.SWFTag"/></f></readTag>
		<read public="1" set="method" line="1380"><f a=""><t path="format.swf.SWF"/></f></read>
		<new public="1" set="method" line="43"><f a="i">
	<c path="haxe.io.Input"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Hash" params="T" file="C:\Program Files\Motion-Twin\haxe/std/Hash.hx">
		<h><c path="flash.utils.Dictionary"/></h>
		<set public="1" set="method" line="63">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="80">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="102">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="133">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="165">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="195">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="240">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="38">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="flash.utils.IDataInput" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/utils/IDataInput.hx" extern="1" interface="1">
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
	</class>
	<class path="flash.utils.ByteArray" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataOutput"/>
		<implements path="flash.utils.IDataInput"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<length public="1"><t path="UInt"/></length>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<position public="1"><t path="UInt"/></position>
		<compress public="1" set="method"><f a=""><e path="Void"/></f></compress>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<uncompress public="1" set="method"><f a=""><e path="Void"/></f></uncompress>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.text.TextFormat" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/text/TextFormat.hx" extern="1">
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<blockIndent public="1"><t path="Null"><c path="Float"/></t></blockIndent>
		<bold public="1"><t path="Null"><e path="Bool"/></t></bold>
		<bullet public="1"><t path="Null"><e path="Bool"/></t></bullet>
		<color public="1"><t path="Null"><t path="UInt"/></t></color>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<font public="1"><c path="String"/></font>
		<indent public="1"><t path="Null"><c path="Float"/></t></indent>
		<italic public="1"><t path="Null"><e path="Bool"/></t></italic>
		<kerning public="1"><t path="Null"><e path="Bool"/></t></kerning>
		<leading public="1"><t path="Null"><c path="Float"/></t></leading>
		<leftMargin public="1"><t path="Null"><c path="Float"/></t></leftMargin>
		<letterSpacing public="1"><t path="Null"><c path="Float"/></t></letterSpacing>
		<rightMargin public="1"><t path="Null"><c path="Float"/></t></rightMargin>
		<size public="1"><t path="Null"><c path="Float"/></t></size>
		<tabStops public="1"><c path="Array"><t path="UInt"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><t path="Null"><e path="Bool"/></t></underline>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.URLRequest" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/net/URLRequest.hx" extern="1">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><d/></data>
		<digest public="1">
			<c path="String"/>
			<haxe_doc> added in FP 9.0.115 </haxe_doc>
		</digest>
		<method public="1"><c path="String"/></method>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/accessibility/AccessibilityProperties.hx" extern="1">
		<description public="1"><c path="String"/></description>
		<forceSimple public="1"><e path="Bool"/></forceSimple>
		<name public="1"><c path="String"/></name>
		<noAutoLabeling public="1"><e path="Bool"/></noAutoLabeling>
		<shortcut public="1"><c path="String"/></shortcut>
		<silent public="1"><e path="Bool"/></silent>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Array" params="T" file="C:\Program Files\Motion-Twin\haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="Std" params="" file="C:\Program Files\Motion-Twin\haxe/std/Std.hx">
		<is public="1" set="method" line="34" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="54" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="74" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="90" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="131" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="153" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
	</enum>
	<class path="format.zip.Writer" params="" file="src/format/zip/Writer.hx">
		<CENTRAL_DIRECTORY_RECORD_FIELDS_SIZE get="inline" set="null" line="39" static="1"><c path="Int"/></CENTRAL_DIRECTORY_RECORD_FIELDS_SIZE>
		<LOCAL_FILE_HEADER_FIELDS_SIZE get="inline" set="null" line="46" static="1"><c path="Int"/></LOCAL_FILE_HEADER_FIELDS_SIZE>
		<o><c path="haxe.io.Output"/></o>
		<files><c path="List"><a>
	<size><c path="Int"/></size>
	<name><c path="String"/></name>
	<fields><c path="haxe.io.Bytes"/></fields>
	<date><c path="Date"/></date>
	<crc><c path="haxe.Int32"/></crc>
	<compressed><e path="Bool"/></compressed>
	<clen><c path="Int"/></clen>
</a></c></files>
		<writeZipDate set="method" line="56"><f a="date">
	<c path="Date"/>
	<e path="Void"/>
</f></writeZipDate>
		<writeEntryHeader public="1" set="method" line="67"><f a="f">
	<t path="format.zip.Entry"/>
	<e path="Void"/>
</f></writeEntryHeader>
		<writeEntryData public="1" set="method" line="121"><f a="e:buf:data">
	<t path="format.zip.Entry"/>
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Input"/>
	<e path="Void"/>
</f></writeEntryData>
		<writeData public="1" set="method" line="125"><f a="files">
	<c path="List"><t path="format.zip.Entry"/></c>
	<e path="Void"/>
</f></writeData>
		<writeCDR public="1" set="method" line="133"><f a=""><e path="Void"/></f></writeCDR>
		<new public="1" set="method" line="51"><f a="o">
	<c path="haxe.io.Output"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.SpreadMethod" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
	</enum>
	<enum path="flash.display.SWFVersion" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/SWFVersion.hx">
		<FLASH9/>
		<FLASH8/>
		<FLASH7/>
		<FLASH6/>
		<FLASH5/>
		<FLASH4/>
		<FLASH3/>
		<FLASH2/>
		<FLASH1/>
	</enum>
	<class path="flash.geom.Matrix" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/geom/Matrix.hx" extern="1">
		<a public="1"><c path="Float"/></a>
		<b public="1"><c path="Float"/></b>
		<c public="1"><c path="Float"/></c>
		<d public="1"><c path="Float"/></d>
		<tx public="1"><c path="Float"/></tx>
		<ty public="1"><c path="Float"/></ty>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<invert public="1" set="method"><f a=""><e path="Void"/></f></invert>
		<rotate public="1" set="method"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<scale public="1" set="method"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/FrameLabel.hx" extern="1">
		<frame public="1" set="null"><c path="Int"/></frame>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.StageQuality" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH/>
		<BEST/>
	</enum>
	<class path="format.swf.Tools" params="" file="src/format/swf/Tools.hx">
		<signExtend public="1" set="method" line="35" static="1"><f a="v:nbits">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></signExtend>
		<floatFixedBits public="1" get="inline" set="null" line="43" static="1"><f a="i:nbits">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
</f></floatFixedBits>
		<floatFixed public="1" get="inline" set="null" line="48" static="1"><f a="i">
	<c path="haxe.Int32"/>
	<c path="Float"/>
</f></floatFixed>
		<floatFixed8 public="1" get="inline" set="null" line="52" static="1"><f a="i">
	<c path="Int"/>
	<c path="Float"/>
</f></floatFixed8>
		<toFixed8 public="1" get="inline" set="null" line="56" static="1"><f a="f">
	<c path="Float"/>
	<c path="Int"/>
</f></toFixed8>
		<toFixed16 public="1" get="inline" set="null" line="64" static="1"><f a="f">
	<c path="Float"/>
	<c path="Int"/>
</f></toFixed16>
		<minBits public="1" get="inline" set="null" line="73" static="1"><f a="values">
	<c path="Array"><c path="Int"/></c>
	<c path="Int"/>
</f></minBits>
		<hex public="1" set="method" line="101" static="1"><f a="b:?max">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="String"/>
</f></hex>
		<bin public="1" set="method" line="115" static="1"><f a="b:?maxBytes">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="String"/>
</f></bin>
		<dumpTag public="1" set="method" line="131" static="1"><f a="t:?max">
	<e path="format.swf.SWFTag"/>
	<c path="Int"/>
	<c path="String"/>
</f></dumpTag>
	</class>
	<class path="be.haxer.hxswfml.ShapeWriter" params="" file="src/be/haxer/hxswfml/ShapeWriter.hx">
		<_shapeType><c path="Int"/></_shapeType>
		<_forceShape3><e path="Bool"/></_forceShape3>
		<_xMin><c path="Float"/></_xMin>
		<_yMin><c path="Float"/></_yMin>
		<_xMax><c path="Float"/></_xMax>
		<_yMax><c path="Float"/></_yMax>
		<_xMin2><c path="Float"/></_xMin2>
		<_yMin2><c path="Float"/></_yMin2>
		<_xMax2><c path="Float"/></_xMax2>
		<_yMax2><c path="Float"/></_yMax2>
		<_boundsInitialized><e path="Bool"/></_boundsInitialized>
		<_fillStyles><c path="Array"><e path="format.swf.FillStyle"/></c></_fillStyles>
		<_lineStyles><c path="Array"><t path="format.swf.LineStyle"/></c></_lineStyles>
		<_shapeRecords><c path="Array"><e path="format.swf.ShapeRecord"/></c></_shapeRecords>
		<_lastX><c path="Float"/></_lastX>
		<_lastY><c path="Float"/></_lastY>
		<_stateFillStyle><e path="Bool"/></_stateFillStyle>
		<_stateLineStyle><e path="Bool"/></_stateLineStyle>
		<beginFill public="1" set="method" line="54"><f a="?color:?alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginGradientFill public="1" set="method" line="68"><f a="?type:colors:alphas:ratios:x:y:scaleX:scaleY:?rotate0:?rotate1">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginBitmapFill public="1" set="method" line="110"><f a="bitmapId:?x:?y:?scaleX:?scaleY:?rotate0:?rotate1:?repeat:?smooth">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<lineStyle public="1" set="method" line="131"><f a="?width:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit:?noClose">
	<c path="Float"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></lineStyle>
		<lineStyle2 set="method" line="155"><f a="?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit:?noClose">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Bool"/>
	<a>
		<startCap><e path="format.swf.LineCapStyle"/></startCap>
		<pixelHinting><t path="Null"><e path="Bool"/></t></pixelHinting>
		<noVScale><e path="Bool"/></noVScale>
		<noHScale><e path="Bool"/></noHScale>
		<noClose><t path="Null"><e path="Bool"/></t></noClose>
		<join><e path="format.swf.LineJoinStyle"/></join>
		<fill><e path="format.swf.LS2Fill"/></fill>
		<endCap><e path="format.swf.LineCapStyle"/></endCap>
	</a>
</f></lineStyle2>
		<lineTo public="1" set="method" line="174"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="195"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<curveTo public="1" set="method" line="223"><f a="cx:cy:ax:ay">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<endFill public="1" set="method" line="250"><f a=""><e path="Void"/></f></endFill>
		<endLine public="1" set="method" line="266"><f a=""><e path="Void"/></f></endLine>
		<clear public="1" set="method" line="282"><f a=""><e path="Void"/></f></clear>
		<drawRect public="1" set="method" line="286"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method" line="294"><f a="x:y:w:h:r">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRoundRectComplex public="1" set="method" line="298"><f a="x:y:w:h:rtl:rtr:rbl:rbr">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<drawCircle public="1" set="method" line="310"><f a="x:y:r:?sections">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method" line="335"><f a="x:y:w:h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<getTag public="1" set="method" line="343"><f a="id:?useWinding:?useNonScalingStroke:?useScalingStroke">
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="format.swf.SWFTag"/>
</f></getTag>
		<initBounds set="method" line="366"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></initBounds>
		<hexToRgba set="method" line="375"><f a="color:alpha">
	<c path="Int"/>
	<c path="Float"/>
	<a>
		<r><c path="Int"/></r>
		<g><c path="Int"/></g>
		<b><c path="Int"/></b>
		<a><c path="Int"/></a>
	</a>
</f></hexToRgba>
		<toFloat5 set="method" line="382"><f a="float">
	<c path="Float"/>
	<c path="Float"/>
</f></toFloat5>
		<new public="1" set="method" line="33"><f a="?forceShape3">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * ...
 * @author Jan J. Flanders
 </haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<class path="flash.Boot" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<init static="1"><f a=""><e path="Void"/></f></init>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.Error"/></lastError>
		<skip_constructor public="1" line="34" static="1"><e path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="89" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="95" static="1"><f a="v:t">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="105" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="113" static="1"><f a="rgb">
	<t path="UInt"/>
	<e path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="117" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="133" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="147" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="187" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<new public="1" set="method" line="36"><f a="?mc">
	<c path="flash.display.MovieClip"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="flash.utils.ByteArray"/></b>
		<writeByte public="1" set="method" line="44" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="52" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<setEndian set="method" line="65" override="1"><f a="e">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<writeFloat public="1" set="method" line="71" override="1"><f a="f">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method" line="75" override="1"><f a="f">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeInt8 public="1" set="method" line="79" override="1"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeInt16 public="1" set="method" line="85" override="1"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeUInt16 public="1" set="method" line="90" override="1"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt31 public="1" set="method" line="95" override="1"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt30 public="1" set="method" line="102" override="1"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt32 public="1" set="method" line="107" override="1"><f a="x">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<prepare public="1" set="method" line="111" override="1"><f a="size">
	<c path="Int"/>
	<e path="Void"/>
</f></prepare>
		<writeString public="1" set="method" line="120" override="1"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<getBytes public="1" set="method" line="126"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="211" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="239" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="278" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="51"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" set="method" line="65"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" set="method" line="93"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="112"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" set="method" line="148"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="192"><f a=""><c path="String"/></f></toString>
		<getData public="1" get="inline" set="null" line="207"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.Event" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<ADDED_TO_STAGE public="1" static="1">
			<c path="String"/>
			<haxe_doc> added in FP 9.0.28 </haxe_doc>
		</ADDED_TO_STAGE>
		<REMOVED_FROM_STAGE public="1" static="1">
			<c path="String"/>
			<haxe_doc> added in FP 9.0.28 </haxe_doc>
		</REMOVED_FROM_STAGE>
		<FULLSCREEN public="1" static="1">
			<c path="String"/>
			<haxe_doc> added in FP 9.0.28 </haxe_doc>
		</FULLSCREEN>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<target public="1" set="null"><d/></target>
		<type public="1" set="null"><c path="String"/></type>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></formatToString>
		<isDefaultPrevented public="1" set="method"><f a=""><e path="Bool"/></f></isDefaultPrevented>
		<preventDefault public="1" set="method"><f a=""><e path="Void"/></f></preventDefault>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Int32" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/Int32.hx">
		<make public="1" get="inline" set="null" line="33" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></make>
		<ofInt public="1" get="inline" set="null" line="41" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ofInt>
		<toInt public="1" get="inline" set="null" line="49" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toInt>
		<toNativeInt public="1" get="inline" set="null" line="62" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toNativeInt>
		<add public="1" get="inline" set="null" line="70" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></add>
		<sub public="1" get="inline" set="null" line="78" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></sub>
		<mul public="1" get="inline" set="null" line="86" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mul>
		<div public="1" get="inline" set="null" line="94" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></div>
		<mod public="1" get="inline" set="null" line="102" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mod>
		<shl public="1" get="inline" set="null" line="110" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shl>
		<shr public="1" get="inline" set="null" line="118" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shr>
		<ushr public="1" get="inline" set="null" line="126" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ushr>
		<and public="1" get="inline" set="null" line="134" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></and>
		<or public="1" get="inline" set="null" line="142" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></or>
		<xor public="1" get="inline" set="null" line="150" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></xor>
		<neg public="1" get="inline" set="null" line="158" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></neg>
		<complement public="1" get="inline" set="null" line="166" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></complement>
		<compare public="1" get="inline" set="null" line="174" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></compare>
	</class>
	<enum path="flash.utils.Endian" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
	</enum>
	<class path="Date" params="" file="C:\Program Files\Motion-Twin\haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new date object.
	</haxe_doc>
		</new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/system/SecurityDomain.hx" extern="1"><currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain></class>
	<enum path="flash.display.BlendMode" params="" file="C:\Program Files\Motion-Twin\haxe/std/flash9/display/BlendMode.hx">
		<SUBTRACT/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
	</enum>
	<class path="StringTools" params="" file="C:\Program Files\Motion-Twin\haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="87" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="98" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="105" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="114" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="122" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="161" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="172" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="194" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="219" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" set="method" line="230" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="format.tools.BitsOutput" params="" file="src/format/tools/BitsOutput.hx">
		<o public="1"><c path="haxe.io.Output"/></o>
		<nbits><c path="Int"/></nbits>
		<bits><c path="Int"/></bits>
		<writeBits public="1" set="method" line="41"><f a="n:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeBits>
		<writeBit public="1" set="method" line="71"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBit>
		<flush public="1" get="inline" set="null" line="81"><f a=""><e path="Void"/></f></flush>
		<new public="1" set="method" line="35"><f a="o">
	<c path="haxe.io.Output"/>
	<e path="Void"/>
</f></new>
	</class>
</haxe>