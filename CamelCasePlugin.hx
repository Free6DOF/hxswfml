//{{{ Importsimport flash.events.KeyboardEvent;import flash.events.MouseEvent;import flash.geom.Point;import flash.geom.Rectangle;import flash.ui.Keyboard;import haxegui.utils.Color;import XmlEditor;//}}}//{{{ EditorPluginclass CamelCasePlugin extends EditorPlugin {	var selection : String;	var _beginIndex : Int;	var camelWords : Array<String>;	static var camelRegex = ~/([?<!^?\wA-Z][a-z]+)/;	public static function main() {	}	public override function start() {		console.log("Starting CamelCase Plugin...");		camelWords = [];		editor.tf.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown, false, 0, true);		editor.tf.addEventListener(KeyboardEvent.KEY_DOWN, onKeyUp, false, 0, true);		editor.tf.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown, false, 0, true);		editor.tf.addEventListener(MouseEvent.DOUBLE_CLICK, onMouseDoubleClick, false, 0, true);	}	public override function run() {	}	public function onMouseDown(e:MouseEvent) {		var tf = editor.tf;		var i  = tf.getLineIndexAtPoint(e.localX, e.localY);		var line = tf.getLineText(i);		// var len = tf.getLineLength(editor.currentLine);		var start = tf.getFirstCharInParagraph(tf.caretIndex);		// var line = tf.text.substr(tf.caretIndex, len);		// var line = tf.text.substr(start, len);		var p = tf.caretIndex - start;		var offset = 0;		var r = ~/(\w+)/;		var m = { pos : 0, len : 0};		var word = "";		while(r.match(line)) {			word = r.matched(0);			m = r.matchedPos();			if((offset+m.pos)==p) {				// trace(word+"\t"+offset);				break;			}			line = r.matchedRight();			offset += m.pos+m.len;		}		var cc = camelRegex;		if(cc.match(word))		camelWords = [];		while(cc.match(word)) {			var camel = cc.matched(0);			m = cc.matchedPos();			word = cc.matchedRight();			camelWords.push(camel);		}		trace(camelWords);	}	public function onMouseDoubleClick(e:MouseEvent) {		var tf = editor.tf;		tf.stage.focus = null;		tf.stage.focus = tf;		tf.setSelection(tf.caretIndex, tf.caretIndex + 1);	}	public function onKeyDown(e:KeyboardEvent) {		// if(!e.ctrlKey && !e.shiftKey) return;		var tf = editor.tf;		var line = tf.getLineText(editor.currentLine);		// var len = tf.getLineLength(editor.currentLine);		var start = tf.getFirstCharInParagraph(tf.caretIndex);		// var line = tf.text.substr(tf.caretIndex, len);		// var line = tf.text.substr(start, len);		var p = tf.caretIndex - start;		var offset = 0;		var r = ~/(\w+)/;		var m = { pos : 0, len : 0};		var word = "";		while(r.match(line)) {			word = r.matched(0);			m = r.matchedPos();			if((offset+m.pos)==p) {				// trace(word+"\t"+offset);				break;			}			line = r.matchedRight();			offset += m.pos+m.len;		}		var cc = camelRegex;		if(cc.match(word))		camelWords = [];		while(cc.match(word)) {			var camel = cc.matched(0);			m = cc.matchedPos();			word = cc.matchedRight();			camelWords.push(camel);		}		trace(camelWords);		// selection = tf.text.substr(tf.selectionBeginIndex, tf.selectionEndIndex - tf.selectionBeginIndex);		// trace(selection);		if(camelWords.length==0) return;		// if(e.ctrlKey && e.shiftKey)		if(e.shiftKey) {			if(e.ctrlKey) {				tf.stage.focus = null;				tf.setSelection(tf.selectionBeginIndex, tf.caretIndex);				return;			}			switch(e.keyCode) {				case Keyboard.RIGHT:				tf.setSelection(tf.selectionBeginIndex, tf.caretIndex + camelWords.shift().length - 1);				case Keyboard.LEFT:				tf.setSelection(tf.caretIndex + 1, tf.caretIndex - camelWords.pop().length);			}		}	}	public function onKeyUp(e:KeyboardEvent) {		var tf = editor.tf;		tf.stage.focus = tf;		if(camelWords.length==0) return;		if(e.ctrlKey)		switch(e.keyCode) {			case Keyboard.RIGHT:			case Keyboard.LEFT:		}	}}//}}}